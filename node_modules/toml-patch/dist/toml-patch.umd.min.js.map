{"version":3,"file":"toml-patch.umd.min.js","sources":["../src/ast.ts","../src/tokenizer.ts","../src/cursor.ts","../src/location.ts","../src/parse-error.ts","../src/utils.ts","../src/parse-string.ts","../src/parse-toml.ts","../src/traverse.ts","../src/writer.ts","../src/generate.ts","../src/format.ts","../src/parse-js.ts","../src/to-toml.ts","../src/to-js.ts","../src/diff.ts","../src/find-by-path.ts","../src/index.ts","../src/patch.ts"],"sourcesContent":["import { Location } from './location';\n\nexport enum NodeType {\n  Document = 'Document',\n  Table = 'Table',\n  TableKey = 'TableKey',\n  TableArray = 'TableArray',\n  TableArrayKey = 'TableArrayKey',\n  KeyValue = 'KeyValue',\n  Key = 'Key',\n  String = 'String',\n  Integer = 'Integer',\n  Float = 'Float',\n  Boolean = 'Boolean',\n  DateTime = 'DateTime',\n  InlineArray = 'InlineArray',\n  InlineItem = 'InlineItem',\n  InlineTable = 'InlineTable',\n  Comment = 'Comment'\n}\n\nexport type AST = Iterable<Block>;\n\n//\n// Document\n//\n// Top-level document that stores AST nodes\n//\nexport interface Document extends Node {\n  type: NodeType.Document;\n  items: Array<Block>;\n}\nexport function isDocument(node: Node): node is Document {\n  return node.type === NodeType.Document;\n}\n\n//\n// Table\n//\n// Top-level object\n//\n// v-------|\n// [table] |\n// b = \"c\" |\n//         |\n// # note  |\n//      ^--|\n// [b]\n//\nexport interface Table extends Node {\n  type: NodeType.Table;\n  key: TableKey;\n  items: Array<KeyValue | Comment>;\n}\nexport function isTable(node: Node): node is Table {\n  return node.type === NodeType.Table;\n}\n\n//\n// TableKey\n//\n// Used to store bracket information for Table keys\n//\n// loc includes brackets\n//\n// [  key  ]\n// ^-------^\n//\nexport interface TableKey extends Node {\n  type: NodeType.TableKey;\n  item: Key;\n}\nexport function isTableKey(node: Node): node is TableKey {\n  return node.type === NodeType.TableKey;\n}\n\n//\n// TableArray\n//\n// Top-level array item\n//\n// v---------|\n// [[array]] |\n// a=\"b\"     |\n//           |\n// # details |\n//         ^-|\n// [[array]]\n//\nexport interface TableArray extends Node {\n  type: NodeType.TableArray;\n  key: TableArrayKey;\n  items: Array<KeyValue | Comment>;\n}\nexport function isTableArray(node: Node): node is TableArray {\n  return node.type === NodeType.TableArray;\n}\n\n//\n// TableArrayKey\n//\n// Used to store bracket information for TableArray keys\n// loc includes brackets\n//\n// [[  key  ]]\n// ^---------^\n//\nexport interface TableArrayKey extends Node {\n  type: NodeType.TableArrayKey;\n  item: Key;\n}\nexport function isTableArrayKey(node: Node): node is TableArrayKey {\n  return node.type === NodeType.TableArrayKey;\n}\n\n//\n// KeyValue\n//\n// Key and Value nodes, with position information on equals sign\n//\n// key=\"value\" # note\n// ^---------^\n//\nexport interface KeyValue extends Node {\n  type: NodeType.KeyValue;\n  key: Key;\n  value: Value;\n\n  // Column index (0-based) of equals sign\n  equals: number;\n}\nexport function isKeyValue(node: Node): node is KeyValue {\n  return node.type === NodeType.KeyValue;\n}\n\n//\n// Key\n//\n// Store raw key and parts (from dots)\n//\nexport interface Key extends Node {\n  type: NodeType.Key;\n  raw: string;\n\n  // Note: Array for keys with dots\n  // e.g. a.b -> raw = 'a.b', value = ['a', 'b']\n  value: string[];\n}\nexport function isKey(node: Node): node is Key {\n  return node.type === NodeType.Key;\n}\n\n//\n// String\n//\n// loc includes quotes\n//\n// a = \"string\"\n//     ^------^\n//\nexport interface String extends Node {\n  type: NodeType.String;\n  raw: string;\n  value: string;\n}\nexport function isString(node: Node): node is String {\n  return node.type === NodeType.String;\n}\n\n//\n// Integer\n//\nexport interface Integer extends Node {\n  type: NodeType.Integer;\n  raw: string;\n  value: number;\n}\nexport function isInteger(node: Node): node is Integer {\n  return node.type === NodeType.Integer;\n}\n\n//\n// Float\n//\nexport interface Float extends Node {\n  type: NodeType.Float;\n  raw: string;\n  value: number;\n}\nexport function isFloat(node: Node): node is Float {\n  return node.type === NodeType.Float;\n}\n\n//\n// Boolean\n//\nexport interface Boolean extends Node {\n  type: NodeType.Boolean;\n\n  // Only `true` and `false` are permitted\n  // -> don't need separate raw and value\n  value: boolean;\n}\nexport function isBoolean(node: Node): node is Boolean {\n  return node.type === NodeType.Boolean;\n}\n\n//\n// DateTime\n//\n// Note: Currently, Offset Date-Time, Local Date-Time, Local Date, and Local Time\n// are handled via raw\n//\nexport interface DateTime extends Node {\n  type: NodeType.DateTime;\n  raw: string;\n  value: Date;\n}\nexport function isDateTime(node: Node): node is DateTime {\n  return node.type === NodeType.DateTime;\n}\n\n//\n// InlineArray\n//\nexport interface InlineArray<TItem = Node> extends Node {\n  type: NodeType.InlineArray;\n  items: InlineArrayItem<TItem>[];\n}\nexport function isInlineArray(node: Node): node is InlineArray {\n  return node.type === NodeType.InlineArray;\n}\n\n//\n// InlineArrayItem\n//\n// loc for InlineArrayItem is from start of value to before comma\n// or end-of-value if no comma\n//\n// [ \"a\"  ,\"b\", \"c\"  ]\n//   ^---^ ^-^  ^-^\n//\nexport interface InlineItem<TItem = Node> extends Node {\n  type: NodeType.InlineItem;\n  item: TItem;\n  comma: boolean;\n}\nexport function isInlineItem(node: Node): node is InlineItem {\n  return node.type === NodeType.InlineItem;\n}\n\nexport interface InlineArrayItem<TItem = Node> extends InlineItem<TItem> {}\n\n//\n// InlineTable\n//\nexport interface InlineTable extends Node {\n  type: NodeType.InlineTable;\n  items: InlineTableItem[];\n}\nexport function isInlineTable(node: Node): node is InlineTable {\n  return node.type === NodeType.InlineTable;\n}\n\n//\n// InlineTableItem\n//\n// loc for InlineTableItem follows InlineArrayItem\n//\n// { a=\"b\"   ,    c =    \"d\"   }\n//   ^------^     ^--------^\n//\nexport interface InlineTableItem extends InlineItem<KeyValue> {}\n\n//\n// Comment\n//\n// loc starts at \"#\" and goes to end of comment (trailing whitespace ignored)\n//\n// # comment here\n// ^------------^\n//\nexport interface Comment extends Node {\n  type: NodeType.Comment;\n  raw: string;\n}\nexport function isComment(node: Node): node is Comment {\n  return node.type === NodeType.Comment;\n}\n\n//\n// Combinations\n//\n\nexport interface WithItems extends Node {\n  items: Node[];\n}\nexport function hasItems(node: Node): node is WithItems {\n  return (\n    isDocument(node) ||\n    isTable(node) ||\n    isTableArray(node) ||\n    isInlineTable(node) ||\n    isInlineArray(node)\n  );\n}\n\nexport interface WithItem extends Node {\n  item: Node;\n}\nexport function hasItem(node: Node): node is WithItem {\n  return isTableKey(node) || isTableArrayKey(node) || isInlineItem(node);\n}\n\nexport type Block = KeyValue | Table | TableArray | Comment;\nexport function isBlock(node: Node): node is Block {\n  return isKeyValue(node) || isTable(node) || isTableArray(node) || isComment(node);\n}\n\nexport type Value<TInlineArrayItem = Node> =\n  | String\n  | Integer\n  | Float\n  | Boolean\n  | DateTime\n  | InlineArray<TInlineArrayItem>\n  | InlineTable;\nexport function isValue(node: Node): node is Value {\n  return (\n    isString(node) ||\n    isInteger(node) ||\n    isFloat(node) ||\n    isBoolean(node) ||\n    isDateTime(node) ||\n    isInlineArray(node) ||\n    isInlineTable(node)\n  );\n}\n\nexport interface Node {\n  type: NodeType;\n  loc: Location;\n}\n","import Cursor, { iterator } from './cursor';\nimport { Location, Locator, createLocate, findPosition } from './location';\nimport ParseError from './parse-error';\n\nexport enum TokenType {\n  Bracket = 'Bracket',\n  Curly = 'Curly',\n  Equal = 'Equal',\n  Comma = 'Comma',\n  Dot = 'Dot',\n  Comment = 'Comment',\n  Literal = 'Literal'\n}\n\nexport interface Token {\n  type: TokenType;\n  raw: string;\n  loc: Location;\n}\n\nexport const IS_WHITESPACE = /\\s/;\nexport const IS_NEW_LINE = /(\\r\\n|\\n)/;\nexport const DOUBLE_QUOTE = `\"`;\nexport const SINGLE_QUOTE = `'`;\nexport const SPACE = ' ';\nexport const ESCAPE = '\\\\';\n\nconst IS_VALID_LEADING_CHARACTER = /[\\w,\\d,\\\",\\',\\+,\\-,\\_]/;\n\nexport function* tokenize(input: string): IterableIterator<Token> {\n  const cursor = new Cursor(iterator(input));\n  cursor.next();\n\n  const locate = createLocate(input);\n\n  while (!cursor.done) {\n    if (IS_WHITESPACE.test(cursor.value!)) {\n      // (skip whitespace)\n    } else if (cursor.value === '[' || cursor.value === ']') {\n      // Handle special characters: [, ], {, }, =, comma\n      yield specialCharacter(cursor, locate, TokenType.Bracket);\n    } else if (cursor.value === '{' || cursor.value === '}') {\n      yield specialCharacter(cursor, locate, TokenType.Curly);\n    } else if (cursor.value === '=') {\n      yield specialCharacter(cursor, locate, TokenType.Equal);\n    } else if (cursor.value === ',') {\n      yield specialCharacter(cursor, locate, TokenType.Comma);\n    } else if (cursor.value === '.') {\n      yield specialCharacter(cursor, locate, TokenType.Dot);\n    } else if (cursor.value === '#') {\n      // Handle comments = # -> EOL\n      yield comment(cursor, locate);\n    } else {\n      const multiline_char =\n        checkThree(input, cursor.index, SINGLE_QUOTE) ||\n        checkThree(input, cursor.index, DOUBLE_QUOTE);\n\n      if (multiline_char) {\n        // Multi-line literals or strings = no escaping\n        yield multiline(cursor, locate, multiline_char, input);\n      } else {\n        yield string(cursor, locate, input);\n      }\n    }\n\n    cursor.next();\n  }\n}\n\nfunction specialCharacter(cursor: Cursor<string>, locate: Locator, type: TokenType): Token {\n  return { type, raw: cursor.value!, loc: locate(cursor.index, cursor.index + 1) };\n}\n\nfunction comment(cursor: Cursor<string>, locate: Locator): Token {\n  const start = cursor.index;\n  let raw = cursor.value!;\n  while (!cursor.peek().done && !IS_NEW_LINE.test(cursor.peek().value!)) {\n    cursor.next();\n    raw += cursor.value!;\n  }\n\n  // Early exit is ok for comment, no closing conditions\n\n  return {\n    type: TokenType.Comment,\n    raw,\n    loc: locate(start, cursor.index + 1)\n  };\n}\n\nfunction multiline(\n  cursor: Cursor<string>,\n  locate: Locator,\n  multiline_char: string,\n  input: string\n): Token {\n  const start = cursor.index;\n  let quotes = multiline_char + multiline_char + multiline_char;\n  let raw = quotes;\n\n  // Skip over quotes\n  cursor.next();\n  cursor.next();\n  cursor.next();\n\n  while (!cursor.done && !checkThree(input, cursor.index, multiline_char)) {\n    raw += cursor.value;\n    cursor.next();\n  }\n\n  if (cursor.done) {\n    throw new ParseError(\n      input,\n      findPosition(input, cursor.index),\n      `Expected close of multiline string with ${quotes}, reached end of file`\n    );\n  }\n\n  raw += quotes;\n\n  cursor.next();\n  cursor.next();\n\n  return {\n    type: TokenType.Literal,\n    raw,\n    loc: locate(start, cursor.index + 1)\n  };\n}\n\nfunction string(cursor: Cursor<string>, locate: Locator, input: string): Token {\n  // Remaining possibilities: keys, strings, literals, integer, float, boolean\n  //\n  // Special cases:\n  // \"...\" -> quoted\n  // '...' -> quoted\n  // \"...\".'...' -> bare\n  // 0000-00-00 00:00:00 -> bare\n  //\n  // See https://github.com/toml-lang/toml#offset-date-time\n  //\n  // | For the sake of readability, you may replace the T delimiter between date and time with a space (as permitted by RFC 3339 section 5.6).\n  // | `odt4 = 1979-05-27 07:32:00Z`\n  //\n  // From RFC 3339:\n  //\n  // | NOTE: ISO 8601 defines date and time separated by \"T\".\n  // | Applications using this syntax may choose, for the sake of\n  // | readability, to specify a full-date and full-time separated by\n  // | (say) a space character.\n\n  // First, check for invalid characters\n  if (!IS_VALID_LEADING_CHARACTER.test(cursor.value!)) {\n    throw new ParseError(\n      input,\n      findPosition(input, cursor.index),\n      `Unsupported character \"${cursor.value}\". Expected ALPHANUMERIC, \", ', +, -, or _`\n    );\n  }\n\n  const start = cursor.index;\n  let raw = cursor.value!;\n  let double_quoted = cursor.value === DOUBLE_QUOTE;\n  let single_quoted = cursor.value === SINGLE_QUOTE;\n\n  const isFinished = (cursor: Cursor<string>) => {\n    if (cursor.peek().done) return true;\n    const next_item = cursor.peek().value!;\n\n    return (\n      !(double_quoted || single_quoted) &&\n      (IS_WHITESPACE.test(next_item) ||\n        next_item === ',' ||\n        next_item === '.' ||\n        next_item === ']' ||\n        next_item === '}' ||\n        next_item === '=')\n    );\n  };\n\n  while (!cursor.done && !isFinished(cursor)) {\n    cursor.next();\n\n    if (cursor.value === DOUBLE_QUOTE) double_quoted = !double_quoted;\n    if (cursor.value === SINGLE_QUOTE && !double_quoted) single_quoted = !single_quoted;\n\n    raw += cursor.value!;\n\n    if (cursor.peek().done) break;\n    let next_item = cursor.peek().value!;\n\n    // If next character is escape and currently double-quoted,\n    // check for escaped quote\n    if (double_quoted && cursor.value === ESCAPE) {\n      if (next_item === DOUBLE_QUOTE) {\n        raw += DOUBLE_QUOTE;\n        cursor.next();\n      } else if (next_item === ESCAPE) {\n        raw += ESCAPE;\n        cursor.next();\n      }\n    }\n  }\n\n  if (double_quoted || single_quoted) {\n    throw new ParseError(\n      input,\n      findPosition(input, start),\n      `Expected close of string with ${double_quoted ? DOUBLE_QUOTE : SINGLE_QUOTE}`\n    );\n  }\n\n  return {\n    type: TokenType.Literal,\n    raw,\n    loc: locate(start, cursor.index + 1)\n  };\n}\n\nfunction checkThree(input: string, current: number, check: string): false | string {\n  return (\n    input[current] === check &&\n    input[current + 1] === check &&\n    input[current + 2] === check &&\n    check\n  );\n}\n","export function iterator<T>(value: Iterable<T>): Iterator<T> {\n  return value[Symbol.iterator]();\n}\n\nexport default class Cursor<T> implements Iterator<T | undefined> {\n  iterator: Iterator<T>;\n  index: number;\n  value?: T;\n  done: boolean;\n  peeked: IteratorResult<T | undefined> | null;\n\n  constructor(iterator: Iterator<T>) {\n    this.iterator = iterator;\n    this.index = -1;\n    this.value = undefined;\n    this.done = false;\n    this.peeked = null;\n  }\n\n  next(): IteratorResult<T | undefined> {\n    if (this.done) return done();\n\n    const result = this.peeked || this.iterator.next();\n\n    this.index += 1;\n    this.value = result.value;\n    this.done = result.done;\n    this.peeked = null;\n\n    return result;\n  }\n\n  peek(): IteratorResult<T | undefined> {\n    if (this.done) return done();\n    if (this.peeked) return this.peeked;\n\n    this.peeked = this.iterator.next();\n    return this.peeked;\n  }\n\n  [Symbol.iterator]() {\n    return this;\n  }\n}\n\nfunction done(): IteratorResult<undefined> {\n  return { value: undefined, done: true };\n}\n","export interface Location {\n  start: Position;\n  end: Position;\n}\n\nexport interface Position {\n  // Note: line is 1-indexed while column is 0-indexed\n  line: number;\n  column: number;\n}\n\nexport interface Span {\n  lines: number;\n  columns: number;\n}\n\nexport function getSpan(location: Location): Span {\n  return {\n    lines: location.end.line - location.start.line + 1,\n    columns: location.end.column - location.start.column\n  };\n}\n\nexport type Locator = (start: number, end: number) => Location;\nexport function createLocate(input: string): Locator {\n  const lines = findLines(input);\n\n  return (start: number, end: number) => {\n    return {\n      start: findPosition(lines, start),\n      end: findPosition(lines, end)\n    };\n  };\n}\n\nexport function findPosition(input: string | number[], index: number): Position {\n  // abc\\ndef\\ng\n  // 0123 4567 8\n  //      012\n  //           0\n  //\n  // lines = [3, 7, 9]\n  //\n  // c = 2: 0 -> 1, 2 - (undefined + 1 || 0) = 2\n  //     3: 0 -> 1, 3 - (undefined + 1 || 0) = 3\n  // e = 5: 1 -> 2, 5 - (3 + 1 || 0) = 1\n  // g = 8: 2 -> 3, 8 - (7 + 1 || 0) = 0\n\n  const lines = Array.isArray(input) ? input : findLines(input);\n  const line = lines.findIndex(line_index => line_index >= index) + 1;\n  const column = index - (lines[line - 2] + 1 || 0);\n\n  return { line, column };\n}\n\nexport function getLine(input: string, position: Position): string {\n  const lines = findLines(input);\n  const start = lines[position.line - 2] || 0;\n  const end = lines[position.line - 1] || input.length;\n\n  return input.substr(start, end - start);\n}\n\nexport function findLines(input: string): number[] {\n  // exec is stateful, so create new regexp each time\n  const BY_NEW_LINE = /[\\r\\n|\\n]/g;\n  const indexes: number[] = [];\n\n  let match;\n  while ((match = BY_NEW_LINE.exec(input)) != null) {\n    indexes.push(match.index);\n  }\n  indexes.push(input.length + 1);\n\n  return indexes;\n}\n\nexport function clonePosition(position: Position): Position {\n  return { line: position.line, column: position.column };\n}\n\nexport function cloneLocation(location: Location): Location {\n  return { start: clonePosition(location.start), end: clonePosition(location.end) };\n}\n\nexport function zero(): Position {\n  return { line: 1, column: 0 };\n}\n","import { Position, getLine } from './location';\n\nexport default class ParseError extends Error {\n  line: number;\n  column: number;\n\n  constructor(input: string, position: Position, message: string) {\n    let error_message = `Error parsing TOML (${position.line}, ${position.column + 1}):\\n`;\n\n    if (input) {\n      const line = getLine(input, position);\n      const pointer = `${whitespace(position.column)}^`;\n\n      if (line) error_message += `${line}\\n${pointer}\\n`;\n    }\n    error_message += message;\n\n    super(error_message);\n\n    this.line = position.line;\n    this.column = position.column;\n  }\n}\n\nexport function isParseError(error: Error): error is ParseError {\n  return error && Object.prototype.hasOwnProperty.call(error, 'line');\n}\n\nfunction whitespace(count: number, character: string = ' '): string {\n  return character.repeat(count);\n}\n","export function last<TValue>(values: TValue[]): TValue | undefined {\n  return values[values.length - 1];\n}\n\nexport type BlankObject = { [key: string]: any };\n\nexport function blank(): BlankObject {\n  return Object.create(null);\n}\n\nexport function isString(value: any): value is string {\n  return typeof value === 'string';\n}\n\nexport function isInteger(value: any): value is number {\n  return typeof value === 'number' && value % 1 === 0;\n}\n\nexport function isFloat(value: any): value is number {\n  return typeof value === 'number' && !isInteger(value);\n}\n\nexport function isBoolean(value: any): value is boolean {\n  return typeof value === 'boolean';\n}\n\nexport function isDate(value: any): value is Date {\n  return Object.prototype.toString.call(value) === '[object Date]';\n}\n\nexport function isObject(value: any): boolean {\n  return value && typeof value === 'object' && !isDate(value) && !Array.isArray(value);\n}\n\nexport function isIterable<T>(value: any): value is Iterable<T> {\n  return value != null && typeof value[Symbol.iterator] === 'function';\n}\n\nexport function has(object: any, key: string): boolean {\n  return Object.prototype.hasOwnProperty.call(object, key);\n}\n\nexport function arraysEqual<TItem>(a: TItem[], b: TItem[]): boolean {\n  if (a.length !== b.length) return false;\n\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n\n  return true;\n}\n\nexport function datesEqual(a: any, b: any): boolean {\n  return isDate(a) && isDate(b) && a.toISOString() === b.toISOString();\n}\n\nexport function pipe<TValue>(value: TValue, ...fns: Array<(value: TValue) => TValue>): TValue {\n  return fns.reduce((value, fn) => fn(value), value);\n}\n\nexport function stableStringify(object: any): string {\n  if (isObject(object)) {\n    const key_values = Object.keys(object)\n      .sort()\n      .map(key => `${JSON.stringify(key)}:${stableStringify(object[key])}`);\n\n    return `{${key_values.join(',')}}`;\n  } else if (Array.isArray(object)) {\n    return `[${object.map(stableStringify).join(',')}]`;\n  } else {\n    return JSON.stringify(object);\n  }\n}\n\nexport function merge<TValue>(target: TValue[], values: TValue[]) {\n  // __mutating__: merge values into target\n  // Reference: https://dev.to/uilicious/javascript-array-push-is-945x-faster-than-array-concat-1oki\n  const original_length = target.length;\n  const added_length = values.length;\n  target.length = original_length + added_length;\n\n  for (let i = 0; i < added_length; i++) {\n    target[original_length + i] = values[i];\n  }\n}\n","import { SINGLE_QUOTE, DOUBLE_QUOTE } from './tokenizer';\nimport { pipe } from './utils';\n\nconst TRIPLE_DOUBLE_QUOTE = `\"\"\"`;\nconst TRIPLE_SINGLE_QUOTE = `'''`;\nconst LF = '\\\\n';\nconst CRLF = '\\\\r\\\\n';\nconst IS_CRLF = /\\r\\n/g;\nconst IS_LF = /\\n/g;\nconst IS_LEADING_NEW_LINE = /^(\\r\\n|\\n)/;\nconst IS_LINE_ENDING_BACKSLASH = /\\\\\\s*[\\n\\r\\n]\\s*/g;\n\nexport function parseString(raw: string): string {\n  if (raw.startsWith(TRIPLE_SINGLE_QUOTE)) {\n    return pipe(\n      trim(raw, 3),\n      trimLeadingWhitespace\n    );\n  } else if (raw.startsWith(SINGLE_QUOTE)) {\n    return trim(raw, 1);\n  } else if (raw.startsWith(TRIPLE_DOUBLE_QUOTE)) {\n    return pipe(\n      trim(raw, 3),\n      trimLeadingWhitespace,\n      lineEndingBackslash,\n      escapeNewLines,\n      unescape\n    );\n  } else if (raw.startsWith(DOUBLE_QUOTE)) {\n    return pipe(\n      trim(raw, 1),\n      unescape\n    );\n  } else {\n    return raw;\n  }\n}\n\nexport function unescape(escaped: string): string {\n  // JSON.parse handles everything except \\UXXXXXXXX\n  // replace those instances with code point, escape that, and then parse\n  const LARGE_UNICODE = /\\\\U[a-fA-F0-9]{8}/g;\n  const json_escaped = escaped.replace(LARGE_UNICODE, value => {\n    const code_point = parseInt(value.replace('\\\\U', ''), 16);\n    const as_string = String.fromCodePoint(code_point);\n\n    return trim(JSON.stringify(as_string), 1);\n  });\n\n  return JSON.parse(`\"${json_escaped}\"`);\n}\n\nexport function escape(value: string): string {\n  return trim(JSON.stringify(value), 1);\n}\n\nfunction trim(value: string, count: number): string {\n  return value.substr(count, value.length - count * 2);\n}\n\nfunction trimLeadingWhitespace(value: string): string {\n  return IS_LEADING_NEW_LINE.test(value) ? value.substr(1) : value;\n}\n\nfunction escapeNewLines(value: string): string {\n  return value.replace(IS_CRLF, CRLF).replace(IS_LF, LF);\n}\n\nfunction lineEndingBackslash(value: string): string {\n  return value.replace(IS_LINE_ENDING_BACKSLASH, '');\n}\n","import {\n  NodeType,\n  KeyValue,\n  Table,\n  TableKey,\n  TableArray,\n  TableArrayKey,\n  Key,\n  Value,\n  String,\n  Integer,\n  Float,\n  Boolean,\n  DateTime,\n  InlineTable,\n  InlineArray,\n  InlineItem,\n  Comment,\n  AST,\n  Block\n} from './ast';\nimport { Token, TokenType, tokenize, DOUBLE_QUOTE, SINGLE_QUOTE } from './tokenizer';\nimport { parseString } from './parse-string';\nimport Cursor from './cursor';\nimport { clonePosition, cloneLocation } from './location';\nimport ParseError from './parse-error';\nimport { merge } from './utils';\n\nconst TRUE = 'true';\nconst FALSE = 'false';\nconst HAS_E = /e/i;\nconst IS_DIVIDER = /\\_/g;\nconst IS_INF = /inf/;\nconst IS_NAN = /nan/;\nconst IS_HEX = /^0x/;\nconst IS_OCTAL = /^0o/;\nconst IS_BINARY = /^0b/;\nexport const IS_FULL_DATE = /(\\d{4})-(\\d{2})-(\\d{2})/;\nexport const IS_FULL_TIME = /(\\d{2}):(\\d{2}):(\\d{2})/;\n\nexport default function* parseTOML(input: string): AST {\n  const tokens = tokenize(input);\n  const cursor = new Cursor(tokens);\n\n  while (!cursor.next().done) {\n    yield* walkBlock(cursor, input);\n  }\n}\n\nfunction* walkBlock(cursor: Cursor<Token>, input: string): IterableIterator<Block> {\n  if (cursor.value!.type === TokenType.Comment) {\n    yield comment(cursor);\n  } else if (cursor.value!.type === TokenType.Bracket) {\n    yield table(cursor, input);\n  } else if (cursor.value!.type === TokenType.Literal) {\n    yield* keyValue(cursor, input);\n  } else {\n    throw new ParseError(\n      input,\n      cursor.value!.loc.start,\n      `Unexpected token \"${cursor.value!.type}\". Expected Comment, Bracket, or String`\n    );\n  }\n}\n\nfunction* walkValue(cursor: Cursor<Token>, input: string): IterableIterator<Value | Comment> {\n  if (cursor.value!.type === TokenType.Literal) {\n    if (cursor.value!.raw[0] === DOUBLE_QUOTE || cursor.value!.raw[0] === SINGLE_QUOTE) {\n      yield string(cursor);\n    } else if (cursor.value!.raw === TRUE || cursor.value!.raw === FALSE) {\n      yield boolean(cursor);\n    } else if (IS_FULL_DATE.test(cursor.value!.raw) || IS_FULL_TIME.test(cursor.value!.raw)) {\n      yield datetime(cursor, input);\n    } else if (\n      (!cursor.peek().done && cursor.peek().value!.type === TokenType.Dot) ||\n      IS_INF.test(cursor.value!.raw) ||\n      IS_NAN.test(cursor.value!.raw) ||\n      (HAS_E.test(cursor.value!.raw) && !IS_HEX.test(cursor.value!.raw))\n    ) {\n      yield float(cursor, input);\n    } else {\n      yield integer(cursor);\n    }\n  } else if (cursor.value!.type === TokenType.Curly) {\n    yield inlineTable(cursor, input);\n  } else if (cursor.value!.type === TokenType.Bracket) {\n    const [inline_array, comments] = inlineArray(cursor, input);\n\n    yield inline_array;\n    yield* comments;\n  } else {\n    throw new ParseError(\n      input,\n      cursor.value!.loc.start,\n      `Unrecognized token type \"${cursor.value!.type}\". Expected String, Curly, or Bracket`\n    );\n  }\n}\n\nfunction comment(cursor: Cursor<Token>): Comment {\n  // # line comment\n  // ^------------^ Comment\n  return {\n    type: NodeType.Comment,\n    loc: cursor.value!.loc,\n    raw: cursor.value!.raw\n  };\n}\n\nfunction table(cursor: Cursor<Token>, input: string): Table | TableArray {\n  // Table or TableArray\n  //\n  // [ key ]\n  // ^-----^    TableKey\n  //   ^-^      Key\n  //\n  // [[ key ]]\n  // ^ ------^  TableArrayKey\n  //    ^-^     Key\n  //\n  // a = \"b\"  < Items\n  // # c      |\n  // d = \"f\"  <\n  //\n  // ...\n  const type =\n    !cursor.peek().done && cursor.peek().value!.type === TokenType.Bracket\n      ? NodeType.TableArray\n      : NodeType.Table;\n  const is_table = type === NodeType.Table;\n\n  if (is_table && cursor.value!.raw !== '[') {\n    throw new ParseError(\n      input,\n      cursor.value!.loc.start,\n      `Expected table opening \"[\", found ${cursor.value!.raw}`\n    );\n  }\n  if (!is_table && (cursor.value!.raw !== '[' || cursor.peek().value!.raw !== '[')) {\n    throw new ParseError(\n      input,\n      cursor.value!.loc.start,\n      `Expected array of tables opening \"[[\", found ${cursor.value!.raw + cursor.peek().value!.raw}`\n    );\n  }\n\n  // Set start location from opening tag\n  const key = is_table\n    ? ({\n        type: NodeType.TableKey,\n        loc: cursor.value!.loc\n      } as Partial<TableKey>)\n    : ({\n        type: NodeType.TableArrayKey,\n        loc: cursor.value!.loc\n      } as Partial<TableArrayKey>);\n\n  // Skip to cursor.value for key value\n  cursor.next();\n  if (type === NodeType.TableArray) cursor.next();\n\n  if (cursor.done) {\n    throw new ParseError(input, key.loc!.start, `Expected table key, reached end of file`);\n  }\n\n  key.item = {\n    type: NodeType.Key,\n    loc: cloneLocation(cursor.value!.loc),\n    raw: cursor.value!.raw,\n    value: [parseString(cursor.value!.raw)]\n  };\n\n  while (!cursor.peek().done && cursor.peek().value!.type === TokenType.Dot) {\n    cursor.next();\n    const dot = cursor.value!;\n\n    cursor.next();\n    const before = ' '.repeat(dot.loc.start.column - key.item.loc.end.column);\n    const after = ' '.repeat(cursor.value!.loc.start.column - dot.loc.end.column);\n\n    key.item.loc.end = cursor.value!.loc.end;\n    key.item.raw += `${before}.${after}${cursor.value!.raw}`;\n    key.item.value.push(parseString(cursor.value!.raw));\n  }\n\n  cursor.next();\n\n  if (is_table && (cursor.done || cursor.value!.raw !== ']')) {\n    throw new ParseError(\n      input,\n      cursor.done ? key.item.loc.end : cursor.value!.loc.start,\n      `Expected table closing \"]\", found ${cursor.done ? 'end of file' : cursor.value!.raw}`\n    );\n  }\n  if (\n    !is_table &&\n    (cursor.done ||\n      cursor.peek().done ||\n      cursor.value!.raw !== ']' ||\n      cursor.peek().value!.raw !== ']')\n  ) {\n    throw new ParseError(\n      input,\n      cursor.done || cursor.peek().done ? key.item.loc.end : cursor.value!.loc.start,\n      `Expected array of tables closing \"]]\", found ${\n        cursor.done || cursor.peek().done\n          ? 'end of file'\n          : cursor.value!.raw + cursor.peek().value!.raw\n      }`\n    );\n  }\n\n  // Set end location from closing tag\n  if (!is_table) cursor.next();\n  key.loc!.end = cursor.value!.loc.end;\n\n  // Add child items\n  let items: Array<KeyValue | Comment> = [];\n  while (!cursor.peek().done && cursor.peek().value!.type !== TokenType.Bracket) {\n    cursor.next();\n    merge(items, [...walkBlock(cursor, input)] as Array<KeyValue | Comment>);\n  }\n\n  return {\n    type: is_table ? NodeType.Table : NodeType.TableArray,\n    loc: {\n      start: clonePosition(key.loc!.start),\n      end: items.length\n        ? clonePosition(items[items.length - 1].loc.end)\n        : clonePosition(key.loc!.end)\n    },\n    key: key as TableKey | TableArrayKey,\n    items\n  } as Table | TableArray;\n}\n\nfunction keyValue(cursor: Cursor<Token>, input: string): Array<KeyValue | Comment> {\n  // 3. KeyValue\n  //\n  // key = value\n  // ^-^          key\n  //     ^        equals\n  //       ^---^  value\n  const key: Key = {\n    type: NodeType.Key,\n    loc: cloneLocation(cursor.value!.loc),\n    raw: cursor.value!.raw,\n    value: [parseString(cursor.value!.raw)]\n  };\n\n  while (!cursor.peek().done && cursor.peek().value!.type === TokenType.Dot) {\n    cursor.next();\n    cursor.next();\n\n    key.loc.end = cursor.value!.loc.end;\n    key.raw += `.${cursor.value!.raw}`;\n    key.value.push(parseString(cursor.value!.raw));\n  }\n\n  cursor.next();\n\n  if (cursor.done || cursor.value!.type !== TokenType.Equal) {\n    throw new ParseError(\n      input,\n      cursor.done ? key.loc.end : cursor.value!.loc.start,\n      `Expected \"=\" for key-value, found ${cursor.done ? 'end of file' : cursor.value!.raw}`\n    );\n  }\n\n  const equals = cursor.value!.loc.start.column;\n\n  cursor.next();\n\n  if (cursor.done) {\n    throw new ParseError(input, key.loc.start, `Expected value for key-value, reached end of file`);\n  }\n\n  const [value, ...comments] = walkValue(cursor, input) as Iterable<Value | Comment>;\n\n  return [\n    {\n      type: NodeType.KeyValue,\n      key,\n      value: value as Value,\n      loc: {\n        start: clonePosition(key.loc.start),\n        end: clonePosition(value.loc.end)\n      },\n      equals\n    },\n    ...(comments as Comment[])\n  ];\n}\n\nfunction string(cursor: Cursor<Token>): String {\n  return {\n    type: NodeType.String,\n    loc: cursor.value!.loc,\n    raw: cursor.value!.raw,\n    value: parseString(cursor.value!.raw)\n  };\n}\n\nfunction boolean(cursor: Cursor<Token>): Boolean {\n  return {\n    type: NodeType.Boolean,\n    loc: cursor.value!.loc,\n    value: cursor.value!.raw === TRUE\n  };\n}\n\nfunction datetime(cursor: Cursor<Token>, input: string): DateTime {\n  // Possible values:\n  //\n  // Offset Date-Time\n  // | odt1 = 1979-05-27T07:32:00Z\n  // | odt2 = 1979-05-27T00:32:00-07:00\n  // | odt3 = 1979-05-27T00:32:00.999999-07:00\n  // | odt4 = 1979-05-27 07:32:00Z\n  //\n  // Local Date-Time\n  // | ldt1 = 1979-05-27T07:32:00\n  // | ldt2 = 1979-05-27T00:32:00.999999\n  //\n  // Local Date\n  // | ld1 = 1979-05-27\n  //\n  // Local Time\n  // | lt1 = 07:32:00\n  // | lt2 = 00:32:00.999999\n  let loc = cursor.value!.loc;\n  let raw = cursor.value!.raw;\n  let value: Date;\n\n  // If next token is string,\n  // check if raw is full date and following is full time\n  if (\n    !cursor.peek().done &&\n    cursor.peek().value!.type === TokenType.Literal &&\n    IS_FULL_DATE.test(raw) &&\n    IS_FULL_TIME.test(cursor.peek().value!.raw)\n  ) {\n    const start = loc.start;\n\n    cursor.next();\n    loc = { start, end: cursor.value!.loc.end };\n    raw += ` ${cursor.value!.raw}`;\n  }\n\n  if (!cursor.peek().done && cursor.peek().value!.type === TokenType.Dot) {\n    const start = loc.start;\n\n    cursor.next();\n\n    if (cursor.peek().done || cursor.peek().value!.type !== TokenType.Literal) {\n      throw new ParseError(input, cursor.value!.loc.end, `Expected fractional value for DateTime`);\n    }\n    cursor.next();\n\n    loc = { start, end: cursor.value!.loc.end };\n    raw += `.${cursor.value!.raw}`;\n  }\n\n  if (!IS_FULL_DATE.test(raw)) {\n    // For local time, use local ISO date\n    const [local_date] = new Date().toISOString().split('T');\n    value = new Date(`${local_date}T${raw}`);\n  } else {\n    value = new Date(raw.replace(' ', 'T'));\n  }\n\n  return {\n    type: NodeType.DateTime,\n    loc,\n    raw,\n    value\n  };\n}\n\nfunction float(cursor: Cursor<Token>, input: string): Float {\n  let loc = cursor.value!.loc;\n  let raw = cursor.value!.raw;\n  let value;\n\n  if (IS_INF.test(raw)) {\n    value = raw === '-inf' ? -Infinity : Infinity;\n  } else if (IS_NAN.test(raw)) {\n    value = raw === '-nan' ? -NaN : NaN;\n  } else if (!cursor.peek().done && cursor.peek().value!.type === TokenType.Dot) {\n    const start = loc.start;\n\n    // From spec:\n    // | A fractional part is a decimal point followed by one or more digits.\n    //\n    // -> Don't have to handle \"4.\" (i.e. nothing behind decimal place)\n\n    cursor.next();\n\n    if (cursor.peek().done || cursor.peek().value!.type !== TokenType.Literal) {\n      throw new ParseError(input, cursor.value!.loc.end, `Expected fraction value for Float`);\n    }\n    cursor.next();\n\n    raw += `.${cursor.value!.raw}`;\n    loc = { start, end: cursor.value!.loc.end };\n    value = Number(raw.replace(IS_DIVIDER, ''));\n  } else {\n    value = Number(raw.replace(IS_DIVIDER, ''));\n  }\n\n  return { type: NodeType.Float, loc, raw, value };\n}\n\nfunction integer(cursor: Cursor<Token>): Integer {\n  // > Integer values -0 and +0 are valid and identical to an unprefixed zero\n  if (cursor.value!.raw === '-0' || cursor.value!.raw === '+0') {\n    return {\n      type: NodeType.Integer,\n      loc: cursor.value!.loc,\n      raw: cursor.value!.raw,\n      value: 0\n    };\n  }\n\n  let radix = 10;\n  if (IS_HEX.test(cursor.value!.raw)) {\n    radix = 16;\n  } else if (IS_OCTAL.test(cursor.value!.raw)) {\n    radix = 8;\n  } else if (IS_BINARY.test(cursor.value!.raw)) {\n    radix = 2;\n  }\n\n  const value = parseInt(\n    cursor\n      .value!.raw.replace(IS_DIVIDER, '')\n      .replace(IS_OCTAL, '')\n      .replace(IS_BINARY, ''),\n    radix\n  );\n\n  return {\n    type: NodeType.Integer,\n    loc: cursor.value!.loc,\n    raw: cursor.value!.raw,\n    value\n  };\n}\n\nfunction inlineTable(cursor: Cursor<Token>, input: string): InlineTable {\n  if (cursor.value!.raw !== '{') {\n    throw new ParseError(\n      input,\n      cursor.value!.loc.start,\n      `Expected \"{\" for inline table, found ${cursor.value!.raw}`\n    );\n  }\n\n  // 6. InlineTable\n  const value: InlineTable = {\n    type: NodeType.InlineTable,\n    loc: cloneLocation(cursor.value!.loc),\n    items: []\n  };\n\n  cursor.next();\n\n  while (\n    !cursor.done &&\n    !(cursor.value!.type === TokenType.Curly && (cursor.value as Token).raw === '}')\n  ) {\n    if ((cursor.value as Token).type === TokenType.Comma) {\n      const previous = value.items[value.items.length - 1];\n      if (!previous) {\n        throw new ParseError(\n          input,\n          cursor.value!.loc.start,\n          'Found \",\" without previous value in inline table'\n        );\n      }\n\n      previous.comma = true;\n      previous.loc.end = cursor.value!.loc.start;\n\n      cursor.next();\n      continue;\n    }\n\n    const [item] = walkBlock(cursor, input);\n    if (item.type !== NodeType.KeyValue) {\n      throw new ParseError(\n        input,\n        cursor.value!.loc.start,\n        `Only key-values are supported in inline tables, found ${item.type}`\n      );\n    }\n\n    const inline_item: InlineItem<KeyValue> = {\n      type: NodeType.InlineItem,\n      loc: cloneLocation(item.loc),\n      item,\n      comma: false\n    };\n\n    value.items.push(inline_item);\n    cursor.next();\n  }\n\n  if (\n    cursor.done ||\n    cursor.value!.type !== TokenType.Curly ||\n    (cursor.value as Token).raw !== '}'\n  ) {\n    throw new ParseError(\n      input,\n      cursor.done ? value.loc.start : cursor.value!.loc.start,\n      `Expected \"}\", found ${cursor.done ? 'end of file' : cursor.value!.raw}`\n    );\n  }\n\n  value.loc.end = cursor.value!.loc.end;\n\n  return value;\n}\n\nfunction inlineArray(cursor: Cursor<Token>, input: string): [InlineArray, Comment[]] {\n  // 7. InlineArray\n  if (cursor.value!.raw !== '[') {\n    throw new ParseError(\n      input,\n      cursor.value!.loc.start,\n      `Expected \"[\" for inline array, found ${cursor.value!.raw}`\n    );\n  }\n\n  const value: InlineArray = {\n    type: NodeType.InlineArray,\n    loc: cloneLocation(cursor.value!.loc),\n    items: []\n  };\n  let comments: Comment[] = [];\n\n  cursor.next();\n\n  while (\n    !cursor.done &&\n    !(cursor.value!.type === TokenType.Bracket && (cursor.value as Token).raw === ']')\n  ) {\n    if ((cursor.value as Token).type === TokenType.Comma) {\n      const previous = value.items[value.items.length - 1];\n      if (!previous) {\n        throw new ParseError(\n          input,\n          cursor.value!.loc.start,\n          'Found \",\" without previous value for inline array'\n        );\n      }\n\n      previous.comma = true;\n      previous.loc.end = cursor.value!.loc.start;\n    } else if ((cursor.value as Token).type === TokenType.Comment) {\n      comments.push(comment(cursor));\n    } else {\n      const [item, ...additional_comments] = walkValue(cursor, input);\n      const inline_item: InlineItem = {\n        type: NodeType.InlineItem,\n        loc: cloneLocation(item.loc),\n        item,\n        comma: false\n      };\n\n      value.items.push(inline_item);\n      merge(comments, additional_comments as Comment[]);\n    }\n\n    cursor.next();\n  }\n\n  if (\n    cursor.done ||\n    cursor.value!.type !== TokenType.Bracket ||\n    (cursor.value as Token).raw !== ']'\n  ) {\n    throw new ParseError(\n      input,\n      cursor.done ? value.loc.start : cursor.value!.loc.start,\n      `Expected \"]\", found ${cursor.done ? 'end of file' : cursor.value!.raw}`\n    );\n  }\n\n  value.loc.end = cursor.value!.loc.end;\n\n  return [value, comments];\n}\n","import {\n  NodeType,\n  AST,\n  Node,\n  Document,\n  Table,\n  TableKey,\n  TableArray,\n  TableArrayKey,\n  KeyValue,\n  Key,\n  String,\n  Integer,\n  Float,\n  Boolean,\n  DateTime,\n  Comment,\n  InlineArray,\n  InlineTable,\n  InlineItem\n} from './ast';\nimport { isIterable } from './utils';\n\nexport type Visit<TNode = Node> = (node: TNode, parent: TNode | null) => void;\nexport type EnterExit<TNode = Node> = { enter?: Visit<TNode>; exit?: Visit<TNode> };\n\nexport type Visitor = {\n  Document?: Visit<Document> | EnterExit<Document>;\n  Table?: Visit<Table> | EnterExit<Table>;\n  TableKey?: Visit<TableKey> | EnterExit<TableKey>;\n  TableArray?: Visit<TableArray> | EnterExit<TableArray>;\n  TableArrayKey?: Visit<TableArrayKey> | EnterExit<TableArrayKey>;\n  KeyValue?: Visit<KeyValue> | EnterExit<KeyValue>;\n  Key?: Visit<Key> | EnterExit<Key>;\n  String?: Visit<String> | EnterExit<String>;\n  Integer?: Visit<Integer> | EnterExit<Integer>;\n  Float?: Visit<Float> | EnterExit<Float>;\n  Boolean?: Visit<Boolean> | EnterExit<Boolean>;\n  DateTime?: Visit<DateTime> | EnterExit<DateTime>;\n  InlineArray?: Visit<InlineArray> | EnterExit<InlineArray>;\n  InlineItem?: Visit<InlineItem> | EnterExit<InlineItem>;\n  InlineTable?: Visit<InlineTable> | EnterExit<InlineTable>;\n  Comment?: Visit<Comment> | EnterExit<Comment>;\n};\n\nexport default function traverse(ast: AST | Node, visitor: Visitor) {\n  if (isIterable(ast)) {\n    traverseArray(ast, null);\n  } else {\n    traverseNode(ast, null);\n  }\n\n  function traverseArray(array: Iterable<Node>, parent: Node | null) {\n    for (const node of array) {\n      traverseNode(node, parent);\n    }\n  }\n\n  function traverseNode(node: Node, parent: Node | null) {\n    const visit = visitor[node.type];\n\n    if (visit && typeof visit === 'function') {\n      (visit as Visit)(node, parent);\n    }\n    if (visit && (visit as EnterExit).enter) {\n      (visit as EnterExit).enter!(node, parent);\n    }\n\n    switch (node.type) {\n      case NodeType.Document:\n        traverseArray((node as Document).items, node);\n        break;\n\n      case NodeType.Table:\n        traverseNode((node as Table).key, node);\n        traverseArray((node as Table).items, node);\n        break;\n      case NodeType.TableKey:\n        traverseNode((node as TableKey).item, node);\n        break;\n\n      case NodeType.TableArray:\n        traverseNode((node as TableArray).key, node);\n        traverseArray((node as TableArray).items, node);\n        break;\n      case NodeType.TableArrayKey:\n        traverseNode((node as TableArrayKey).item, node);\n        break;\n\n      case NodeType.KeyValue:\n        traverseNode((node as KeyValue).key, node);\n        traverseNode((node as KeyValue).value, node);\n        break;\n\n      case NodeType.InlineArray:\n        traverseArray((node as InlineArray).items, node);\n        break;\n      case NodeType.InlineItem:\n        traverseNode((node as InlineItem).item, node);\n        break;\n\n      case NodeType.InlineTable:\n        traverseArray((node as InlineTable).items, node);\n        break;\n\n      case NodeType.Key:\n      case NodeType.String:\n      case NodeType.Integer:\n      case NodeType.Float:\n      case NodeType.Boolean:\n      case NodeType.DateTime:\n      case NodeType.Comment:\n        break;\n\n      default:\n        throw new Error(`Unrecognized node type \"${node.type}\"`);\n    }\n\n    if (visit && (visit as EnterExit).exit) {\n      (visit as EnterExit).exit!(node, parent);\n    }\n  }\n}\n","import {\n  NodeType,\n  Node,\n  Document,\n  Key,\n  Value,\n  InlineArray,\n  InlineArrayItem,\n  InlineTableItem,\n  isKeyValue,\n  isTable,\n  isTableArray,\n  isInlineTable,\n  isInlineArray,\n  hasItems,\n  hasItem,\n  isComment,\n  isDocument,\n  InlineTable,\n  TableArray,\n  Table,\n  KeyValue,\n  Comment,\n  InlineItem,\n  isInlineItem,\n  Block,\n  isBlock\n} from './ast';\nimport { Span, getSpan, clonePosition } from './location';\nimport { last } from './utils';\nimport traverse from './traverse';\n\nexport type Root = Document | Node;\n\n// Store line and column offsets per node\n//\n// Some offsets are applied on enter (e.g. shift child items and next items)\n// Others are applied on exit (e.g. shift next items)\ntype Offsets = WeakMap<Node, Span>;\n\nconst enter_offsets: WeakMap<Root, Offsets> = new WeakMap();\nconst getEnter = (root: Root) => {\n  if (!enter_offsets.has(root)) {\n    enter_offsets.set(root, new WeakMap());\n  }\n  return enter_offsets.get(root)!;\n};\n\nconst exit_offsets: WeakMap<Root, Offsets> = new WeakMap();\nconst getExit = (root: Root) => {\n  if (!exit_offsets.has(root)) {\n    exit_offsets.set(root, new WeakMap());\n  }\n  return exit_offsets.get(root)!;\n};\n\nexport function replace(root: Root, parent: Node, existing: Node, replacement: Node) {\n  // First, replace existing node\n  // (by index for items, item, or key/value)\n  if (hasItems(parent)) {\n    const index = parent.items.indexOf(existing);\n    if (index < 0) throw new Error(`Could not find existing item in parent node for replace`);\n\n    parent.items.splice(index, 1, replacement);\n  } else if (hasItem(parent)) {\n    parent.item = replacement;\n  } else if (isKeyValue(parent)) {\n    if (parent.key === existing) {\n      parent.key = replacement as Key;\n    } else {\n      parent.value = replacement as Value;\n    }\n  } else {\n    throw new Error(`Unsupported parent type \"${parent.type}\" for replace`);\n  }\n\n  // Shift the replacement node into the same start position as existing\n  const shift = {\n    lines: existing.loc.start.line - replacement.loc.start.line,\n    columns: existing.loc.start.column - replacement.loc.start.column\n  };\n  shiftNode(replacement, shift);\n\n  // Apply offsets after replacement node\n  const existing_span = getSpan(existing.loc);\n  const replacement_span = getSpan(replacement.loc);\n  const offset = {\n    lines: replacement_span.lines - existing_span.lines,\n    columns: replacement_span.columns - existing_span.columns\n  };\n\n  addOffset(offset, getExit(root), replacement, existing);\n}\n\nexport function insert(root: Root, parent: Node, child: Node, index?: number) {\n  if (!hasItems(parent)) {\n    throw new Error(`Unsupported parent type \"${(parent as Node).type}\" for insert`);\n  }\n\n  index = index != null ? index : parent.items.length;\n\n  let shift: Span;\n  let offset: Span;\n  if (isInlineArray(parent) || isInlineTable(parent)) {\n    ({ shift, offset } = insertInline(parent, child as InlineItem, index));\n  } else {\n    ({ shift, offset } = insertOnNewLine(\n      parent as Document | Table | TableArray,\n      child as KeyValue | Comment,\n      index\n    ));\n  }\n\n  shiftNode(child, shift);\n\n  // The child element is placed relative to the previous element,\n  // if the previous element has an offset, need to position relative to that\n  // -> Move previous offset to child's offset\n  const previous = parent.items[index - 1];\n  const previous_offset = previous && getExit(root).get(previous);\n  if (previous_offset) {\n    offset.lines += previous_offset.lines;\n    offset.columns += previous_offset.columns;\n\n    // Account for comma overlay\n    //\n    // a = [b, e]\n    // a = [b, c, e]\n    //       ^---^\n    // a = [b, c, d, e]\n    //          ^---^\n    if (isInlineItem(child) && previous && parent.items[index + 1]) {\n      offset.columns -= 2;\n    }\n\n    getExit(root).delete(previous!);\n  }\n\n  const offsets = getExit(root);\n  offsets.set(child, offset);\n}\n\nfunction insertOnNewLine(\n  parent: Document | Table | TableArray,\n  child: Block,\n  index: number\n): { shift: Span; offset: Span } {\n  if (!isBlock(child)) {\n    throw new Error(`Incompatible child type \"${(child as Node).type}\"`);\n  }\n\n  const previous = parent.items[index - 1];\n  const use_first_line = isDocument(parent) && !parent.items.length;\n\n  parent.items.splice(index, 0, child);\n\n  // Set start location from previous item or start of array\n  // (previous is undefined for empty array or inserting at first item)\n  const start = previous\n    ? {\n        line: previous.loc.end.line,\n        column: !isComment(previous) ? previous.loc.start.column : parent.loc.start.column\n      }\n    : clonePosition(parent.loc.start);\n\n  const is_block = isTable(child) || isTableArray(child);\n  let leading_lines = 0;\n  if (use_first_line) {\n    // 0 leading lines\n  } else if (is_block) {\n    leading_lines = 2;\n  } else {\n    leading_lines = 1;\n  }\n  start.line += leading_lines;\n\n  const shift = {\n    lines: start.line - child.loc.start.line,\n    columns: start.column - child.loc.start.column\n  };\n\n  // Apply offsets after child node\n  const child_span = getSpan(child.loc);\n  const offset = {\n    lines: child_span.lines + (leading_lines - 1),\n    columns: child_span.columns\n  };\n\n  return { shift, offset };\n}\n\nfunction insertInline(\n  parent: InlineArray | InlineTable,\n  child: InlineItem,\n  index: number\n): { shift: Span; offset: Span } {\n  if (!isInlineItem(child)) {\n    throw new Error(`Incompatible child type \"${(child as Node).type}\"`);\n  }\n\n  // Store preceding node and insert\n  const previous = index != null ? parent.items[index - 1] : last(parent.items);\n  const is_last = index == null || index === parent.items.length;\n\n  parent.items.splice(index, 0, child);\n\n  // Add commas as-needed\n  const leading_comma = !!previous;\n  const trailing_comma = !is_last;\n  const last_comma = is_last && child.comma === true;\n  if (leading_comma) {\n    previous!.comma = true;\n  }\n  if (trailing_comma) {\n    child.comma = true;\n  }\n\n  // Use a new line for documents, children of Table/TableArray,\n  // and if an inline table is using new lines\n  const use_new_line = isInlineArray(parent) && perLine(parent);\n\n  // Set start location from previous item or start of array\n  // (previous is undefined for empty array or inserting at first item)\n  const start = previous\n    ? {\n        line: previous.loc.end.line,\n        column: use_new_line\n          ? !isComment(previous)\n            ? previous.loc.start.column\n            : parent.loc.start.column\n          : previous.loc.end.column\n      }\n    : clonePosition(parent.loc.start);\n\n  let leading_lines = 0;\n  if (use_new_line) {\n    leading_lines = 1;\n  } else {\n    const skip_comma = 2;\n    const skip_bracket = 1;\n    start.column += leading_comma ? skip_comma : skip_bracket;\n  }\n  start.line += leading_lines;\n\n  const shift = {\n    lines: start.line - child.loc.start.line,\n    columns: start.column - child.loc.start.column\n  };\n\n  // Apply offsets after child node\n  const child_span = getSpan(child.loc);\n  const offset = {\n    lines: child_span.lines + (leading_lines - 1),\n    columns: child_span.columns + (leading_comma || trailing_comma ? 2 : 0) + (last_comma ? 1 : 0)\n  };\n\n  return { shift, offset };\n}\n\nexport function remove(root: Root, parent: Node, node: Node) {\n  // Remove an element from the parent's items\n  // (supports Document, Table, TableArray, InlineTable, and InlineArray\n  //\n  //      X\n  // [ 1, 2, 3 ]\n  //    ^-^\n  // -> Remove element 2 and apply 0,-3 offset to 1\n  //\n  // [table]\n  // a = 1\n  // b = 2 # X\n  // c = 3\n  // -> Remove element 2 and apply -1,0 offset to 1\n  if (!hasItems(parent)) {\n    throw new Error(`Unsupported parent type \"${parent.type}\" for remove`);\n  }\n\n  let index = parent.items.indexOf(node);\n  if (index < 0) {\n    // Try again, looking at child items for nodes like InlineArrayItem\n    index = parent.items.findIndex(item => hasItem(item) && item.item === node);\n\n    if (index < 0) {\n      throw new Error('Could not find node in parent for removal');\n    }\n\n    node = parent.items[index];\n  }\n\n  const previous = parent.items[index - 1];\n  let next = parent.items[index + 1];\n\n  // Remove node\n  parent.items.splice(index, 1);\n  let removed_span = getSpan(node.loc);\n\n  // Remove an associated comment that appears on the same line\n  //\n  // [table]\n  // a = 1\n  // b = 2 # remove this too\n  // c = 3\n  //\n  // TODO InlineTable - this only applies to comments in Table/TableArray\n  if (next && isComment(next) && next.loc.start.line === node.loc.end.line) {\n    // Add comment to removed\n    removed_span = getSpan({ start: node.loc.start, end: next.loc.end });\n\n    // Shift to next item\n    // (use same index since node has already been removed)\n    next = parent.items[index + 1];\n\n    // Remove comment\n    parent.items.splice(index, 1);\n  }\n\n  // For inline tables and arrays, check whether the line should be kept\n  const is_inline = previous && isInlineItem(previous);\n  const previous_on_same_line = previous && previous.loc.end.line === node.loc.start.line;\n  const next_on_sameLine = next && next.loc.start.line === node.loc.end.line;\n  const keep_line = is_inline && (previous_on_same_line || next_on_sameLine);\n\n  const offset = {\n    lines: -(removed_span.lines - (keep_line ? 1 : 0)),\n    columns: -removed_span.columns\n  };\n\n  // Offset for comma and remove comma from previous (if-needed)\n  if (is_inline && previous_on_same_line) {\n    offset.columns -= 2;\n  }\n  if (is_inline && previous && !next) {\n    (previous as InlineArrayItem | InlineTableItem).comma = false;\n  }\n\n  // Apply offsets after preceding node or before children of parent node\n  const target = previous || parent;\n  const target_offsets = previous ? getExit(root) : getEnter(root);\n  const node_offsets = getExit(root);\n  const previous_offset = target_offsets.get(target);\n  if (previous_offset) {\n    offset.lines += previous_offset.lines;\n    offset.columns += previous_offset.columns;\n  }\n  const removed_offset = node_offsets.get(node);\n  if (removed_offset) {\n    offset.lines += removed_offset.lines;\n    offset.columns += removed_offset.columns;\n  }\n\n  target_offsets.set(target, offset);\n}\n\nexport function applyBracketSpacing(\n  root: Root,\n  node: InlineArray | InlineTable,\n  bracket_spacing: boolean = true\n) {\n  // Can only add bracket spacing currently\n  if (!bracket_spacing) return;\n  if (!node.items.length) return;\n\n  // Apply enter to node so that items are affected\n  addOffset({ lines: 0, columns: 1 }, getEnter(root), node);\n\n  // Apply exit to last node in items\n  const last_item = last(node.items as Node[])!;\n  addOffset({ lines: 0, columns: 1 }, getExit(root), last_item);\n}\n\nexport function applyTrailingComma(\n  root: Root,\n  node: InlineArray | InlineTable,\n  trailing_commas: boolean = false\n) {\n  // Can only add trailing comma currently\n  if (!trailing_commas) return;\n  if (!node.items.length) return;\n\n  const last_item = last(node.items)!;\n  last_item.comma = true;\n\n  addOffset({ lines: 0, columns: 1 }, getExit(root), last_item);\n}\n\nexport function applyWrites(root: Node) {\n  const enter = getEnter(root);\n  const exit = getExit(root);\n\n  const offset: { lines: number; columns: { [index: number]: number } } = {\n    lines: 0,\n    columns: {}\n  };\n\n  function shiftStart(node: Node) {\n    node.loc.start.line += offset.lines;\n    node.loc.start.column += offset.columns[node.loc.start.line] || 0;\n\n    const entering = enter.get(node);\n    if (entering) {\n      offset.lines += entering.lines;\n      offset.columns[node.loc.start.line] =\n        (offset.columns[node.loc.start.line] || 0) + entering.columns;\n    }\n  }\n  function shiftEnd(node: Node) {\n    node.loc.end.line += offset.lines;\n    node.loc.end.column += offset.columns[node.loc.end.line] || 0;\n\n    const exiting = exit.get(node);\n    if (exiting) {\n      offset.lines += exiting.lines;\n      offset.columns[node.loc.end.line] =\n        (offset.columns[node.loc.end.line] || 0) + exiting.columns;\n    }\n  }\n  const shiftLocation = {\n    enter: shiftStart,\n    exit: shiftEnd\n  };\n\n  traverse(root, {\n    [NodeType.Document]: shiftLocation,\n    [NodeType.Table]: shiftLocation,\n    [NodeType.TableArray]: shiftLocation,\n    [NodeType.InlineTable]: shiftLocation,\n    [NodeType.InlineArray]: shiftLocation,\n\n    [NodeType.InlineItem]: shiftLocation,\n    [NodeType.TableKey]: shiftLocation,\n    [NodeType.TableArrayKey]: shiftLocation,\n\n    [NodeType.KeyValue]: {\n      enter(node) {\n        const start_line = node.loc.start.line + offset.lines;\n        const key_offset = exit.get(node.key);\n        node.equals += (offset.columns[start_line] || 0) + (key_offset ? key_offset.columns : 0);\n\n        shiftStart(node);\n      },\n      exit: shiftEnd\n    },\n\n    [NodeType.Key]: shiftLocation,\n    [NodeType.String]: shiftLocation,\n    [NodeType.Integer]: shiftLocation,\n    [NodeType.Float]: shiftLocation,\n    [NodeType.Boolean]: shiftLocation,\n    [NodeType.DateTime]: shiftLocation,\n    [NodeType.Comment]: shiftLocation\n  });\n\n  enter_offsets.delete(root);\n  exit_offsets.delete(root);\n}\n\nexport function shiftNode(\n  node: Node,\n  span: Span,\n  options: { first_line_only?: boolean } = {}\n): Node {\n  const { first_line_only = false } = options;\n  const start_line = node.loc.start.line;\n  const { lines, columns } = span;\n  const move = (node: Node) => {\n    if (!first_line_only || node.loc.start.line === start_line) {\n      node.loc.start.column += columns;\n      node.loc.end.column += columns;\n    }\n    node.loc.start.line += lines;\n    node.loc.end.line += lines;\n  };\n\n  traverse(node, {\n    [NodeType.Table]: move,\n    [NodeType.TableKey]: move,\n    [NodeType.TableArray]: move,\n    [NodeType.TableArrayKey]: move,\n    [NodeType.KeyValue](node) {\n      move(node);\n      node.equals += columns;\n    },\n    [NodeType.Key]: move,\n    [NodeType.String]: move,\n    [NodeType.Integer]: move,\n    [NodeType.Float]: move,\n    [NodeType.Boolean]: move,\n    [NodeType.DateTime]: move,\n    [NodeType.InlineArray]: move,\n    [NodeType.InlineItem]: move,\n    [NodeType.InlineTable]: move,\n    [NodeType.Comment]: move\n  });\n\n  return node;\n}\n\nfunction perLine(array: InlineArray): boolean {\n  if (!array.items.length) return false;\n\n  const span = getSpan(array.loc);\n  return span.lines > array.items.length;\n}\n\nfunction addOffset(offset: Span, offsets: Offsets, node: Node, from?: Node) {\n  const previous_offset = offsets.get(from || node);\n  if (previous_offset) {\n    offset.lines += previous_offset.lines;\n    offset.columns += previous_offset.columns;\n  }\n\n  offsets.set(node, offset);\n}\n","import {\n  NodeType,\n  Document,\n  Table,\n  TableKey,\n  TableArray,\n  TableArrayKey,\n  Value,\n  KeyValue,\n  Key,\n  String,\n  Integer,\n  Float,\n  Boolean,\n  DateTime,\n  InlineArray,\n  InlineItem,\n  InlineTable,\n  Comment\n} from './ast';\nimport { zero, cloneLocation, clonePosition } from './location';\nimport { shiftNode } from './writer';\n\nexport function generateDocument(): Document {\n  return {\n    type: NodeType.Document,\n    loc: { start: zero(), end: zero() },\n    items: []\n  };\n}\n\nexport function generateTable(key: string[]): Table {\n  const table_key = generateTableKey(key);\n\n  return {\n    type: NodeType.Table,\n    loc: cloneLocation(table_key.loc),\n    key: table_key,\n    items: []\n  };\n}\n\nexport function generateTableKey(key: string[]): TableKey {\n  const raw = keyValueToRaw(key);\n\n  return {\n    type: NodeType.TableKey,\n    loc: {\n      start: zero(),\n      end: { line: 1, column: raw.length + 2 }\n    },\n    item: {\n      type: NodeType.Key,\n      loc: {\n        start: { line: 1, column: 1 },\n        end: { line: 1, column: raw.length + 1 }\n      },\n      value: key,\n      raw\n    }\n  };\n}\n\nexport function generateTableArray(key: string[]): TableArray {\n  const table_array_key = generateTableArrayKey(key);\n\n  return {\n    type: NodeType.TableArray,\n    loc: cloneLocation(table_array_key.loc),\n    key: table_array_key,\n    items: []\n  };\n}\n\nexport function generateTableArrayKey(key: string[]): TableArrayKey {\n  const raw = keyValueToRaw(key);\n\n  return {\n    type: NodeType.TableArrayKey,\n    loc: {\n      start: zero(),\n      end: { line: 1, column: raw.length + 4 }\n    },\n    item: {\n      type: NodeType.Key,\n      loc: {\n        start: { line: 1, column: 2 },\n        end: { line: 1, column: raw.length + 2 }\n      },\n      value: key,\n      raw\n    }\n  };\n}\n\nexport function generateKeyValue(key: string[], value: Value): KeyValue {\n  const key_node = generateKey(key);\n  const { column } = key_node.loc.end;\n\n  const equals = column + 1;\n\n  shiftNode(\n    value,\n    { lines: 0, columns: column + 3 - value.loc.start.column },\n    { first_line_only: true }\n  );\n\n  return {\n    type: NodeType.KeyValue,\n    loc: {\n      start: clonePosition(key_node.loc.start),\n      end: clonePosition(value.loc.end)\n    },\n    key: key_node,\n    equals,\n    value\n  };\n}\n\nconst IS_BARE_KEY = /[\\w,\\d,\\_,\\-]+/;\nfunction keyValueToRaw(value: string[]): string {\n  return value.map(part => (IS_BARE_KEY.test(part) ? part : JSON.stringify(part))).join('.');\n}\n\nexport function generateKey(value: string[]): Key {\n  const raw = keyValueToRaw(value);\n\n  return {\n    type: NodeType.Key,\n    loc: { start: zero(), end: { line: 1, column: raw.length } },\n    raw,\n    value\n  };\n}\n\nexport function generateString(value: string): String {\n  const raw = JSON.stringify(value);\n\n  return {\n    type: NodeType.String,\n    loc: { start: zero(), end: { line: 1, column: raw.length } },\n    raw,\n    value\n  };\n}\n\nexport function generateInteger(value: number): Integer {\n  const raw = value.toString();\n\n  return {\n    type: NodeType.Integer,\n    loc: { start: zero(), end: { line: 1, column: raw.length } },\n    raw,\n    value\n  };\n}\n\nexport function generateFloat(value: number): Float {\n  const raw = value.toString();\n\n  return {\n    type: NodeType.Float,\n    loc: { start: zero(), end: { line: 1, column: raw.length } },\n    raw,\n    value\n  };\n}\n\nexport function generateBoolean(value: boolean): Boolean {\n  return {\n    type: NodeType.Boolean,\n    loc: { start: zero(), end: { line: 1, column: value ? 4 : 5 } },\n    value\n  };\n}\n\nexport function generateDateTime(value: Date): DateTime {\n  const raw = value.toISOString();\n\n  return {\n    type: NodeType.DateTime,\n    loc: { start: zero(), end: { line: 1, column: raw.length } },\n    raw,\n    value\n  };\n}\n\nexport function generateInlineArray(): InlineArray {\n  return {\n    type: NodeType.InlineArray,\n    loc: { start: zero(), end: { line: 1, column: 2 } },\n    items: []\n  };\n}\n\nexport function generateInlineItem(item: KeyValue | Value): InlineItem {\n  return {\n    type: NodeType.InlineItem,\n    loc: cloneLocation(item.loc),\n    item,\n    comma: false\n  };\n}\n\nexport function generateInlineTable(): InlineTable {\n  return {\n    type: NodeType.InlineTable,\n    loc: { start: zero(), end: { line: 1, column: 2 } },\n    items: []\n  };\n}\n\nexport function generateComment(comment: string): Comment {\n  if (!comment.startsWith('#')) comment = `# ${comment}`;\n\n  return {\n    type: NodeType.Comment,\n    loc: { start: zero(), end: { line: 1, column: comment.length } },\n    raw: comment\n  };\n}\n","import {\n  KeyValue,\n  Table,\n  InlineTable,\n  TableArray,\n  InlineArray,\n  isInlineTable,\n  isInlineArray,\n  isKeyValue,\n  Document\n} from './ast';\nimport { generateTable, generateDocument, generateTableArray } from './generate';\nimport { insert, remove, applyWrites, shiftNode } from './writer';\n\nexport interface Format {\n  printWidth?: number;\n  tabWidth?: number;\n  useTabs?: boolean;\n  trailingComma?: boolean;\n  bracketSpacing?: boolean;\n}\n\nexport function formatTopLevel(document: Document): Document {\n  const move_to_top_level = document.items.filter(item => {\n    if (!isKeyValue(item)) return false;\n\n    const is_inline_table = isInlineTable(item.value);\n    const is_inline_array =\n      isInlineArray(item.value) &&\n      item.value.items.length &&\n      isInlineTable(item.value.items[0].item);\n\n    return is_inline_table || is_inline_array;\n  }) as KeyValue[];\n\n  move_to_top_level.forEach(node => {\n    remove(document, document, node);\n\n    if (isInlineTable(node.value)) {\n      insert(document, document, formatTable(node));\n    } else {\n      formatTableArray(node).forEach(table_array => {\n        insert(document, document, table_array);\n      });\n    }\n  });\n\n  applyWrites(document);\n  return document;\n}\n\nfunction formatTable(key_value: KeyValue): Table {\n  const table = generateTable(key_value.key.value);\n\n  for (const item of (key_value.value as InlineTable).items) {\n    insert(table, table, item.item);\n  }\n\n  applyWrites(table);\n  return table;\n}\n\nfunction formatTableArray(key_value: KeyValue): TableArray[] {\n  const root = generateDocument();\n\n  for (const inline_array_item of (key_value.value as InlineArray).items) {\n    const table_array = generateTableArray(key_value.key.value);\n    insert(root, root, table_array);\n\n    for (const inline_table_item of (inline_array_item.item as InlineTable).items) {\n      insert(root, table_array, inline_table_item.item);\n    }\n  }\n\n  applyWrites(root);\n  return root.items as TableArray[];\n}\n\nexport function formatPrintWidth(document: Document, format: Format): Document {\n  // TODO\n  return document;\n}\n\nexport function formatEmptyLines(document: Document): Document {\n  let shift = 0;\n  let previous = 0;\n  for (const item of document.items) {\n    if (previous === 0 && item.loc.start.line > 1) {\n      // Remove leading newlines\n      shift = 1 - item.loc.start.line;\n    } else if (item.loc.start.line + shift > previous + 2) {\n      shift += previous + 2 - (item.loc.start.line + shift);\n    }\n\n    shiftNode(item, {\n      lines: shift,\n      columns: 0\n    });\n    previous = item.loc.end.line;\n  }\n\n  return document;\n}\n","import { Value, KeyValue, Document, InlineArray, InlineTable } from './ast';\nimport {\n  generateDocument,\n  generateKeyValue,\n  generateInlineItem,\n  generateString,\n  generateInteger,\n  generateFloat,\n  generateBoolean,\n  generateDateTime,\n  generateInlineArray,\n  generateInlineTable\n} from './generate';\nimport { Format, formatTopLevel, formatPrintWidth, formatEmptyLines } from './format';\nimport { isObject, isString, isInteger, isFloat, isBoolean, isDate, pipe } from './utils';\nimport { insert, applyWrites, applyBracketSpacing, applyTrailingComma } from './writer';\n\nconst default_format = {\n  printWidth: 80,\n  trailingComma: false,\n  bracketSpacing: true\n};\n\nexport default function parseJS(value: any, format: Format = {}): Document {\n  format = Object.assign({}, default_format, format);\n  value = toJSON(value);\n\n  const document = generateDocument();\n  for (const item of walkObject(value, format)) {\n    insert(document, document, item);\n  }\n  applyWrites(document);\n\n  // Heuristics:\n  // 1. Top-level objects/arrays should be tables/table arrays\n  // 2. Convert objects/arrays to tables/table arrays based on print width\n  const formatted = pipe(\n    document,\n    formatTopLevel,\n    document => formatPrintWidth(document, format),\n    formatEmptyLines\n  );\n\n  return formatted;\n}\n\nfunction* walkObject(object: any, format: Format): IterableIterator<KeyValue> {\n  for (const key of Object.keys(object)) {\n    yield generateKeyValue([key], walkValue(object[key], format));\n  }\n}\n\nfunction walkValue(value: any, format: Format): Value {\n  if (value == null) {\n    throw new Error('\"null\" and \"undefined\" values are not supported');\n  }\n\n  if (isString(value)) {\n    return generateString(value);\n  } else if (isInteger(value)) {\n    return generateInteger(value);\n  } else if (isFloat(value)) {\n    return generateFloat(value);\n  } else if (isBoolean(value)) {\n    return generateBoolean(value);\n  } else if (isDate(value)) {\n    return generateDateTime(value);\n  } else if (Array.isArray(value)) {\n    return walkInlineArray(value, format);\n  } else {\n    return walkInlineTable(value, format);\n  }\n}\n\nfunction walkInlineArray(value: Array<any>, format: Format): InlineArray {\n  const inline_array = generateInlineArray();\n  for (const element of value) {\n    const item = walkValue(element, format);\n    const inline_array_item = generateInlineItem(item);\n\n    insert(inline_array, inline_array, inline_array_item);\n  }\n  applyBracketSpacing(inline_array, inline_array, format.bracketSpacing);\n  applyTrailingComma(inline_array, inline_array, format.trailingComma);\n  applyWrites(inline_array);\n\n  return inline_array;\n}\n\nfunction walkInlineTable(value: object, format: Format): InlineTable | Value {\n  value = toJSON(value);\n  if (!isObject(value)) return walkValue(value, format);\n\n  const inline_table = generateInlineTable();\n  const items = [...walkObject(value, format)];\n  for (const item of items) {\n    const inline_table_item = generateInlineItem(item);\n\n    insert(inline_table, inline_table, inline_table_item);\n  }\n  applyBracketSpacing(inline_table, inline_table, format.bracketSpacing);\n  applyTrailingComma(inline_table, inline_table, format.trailingComma);\n  applyWrites(inline_table);\n\n  return inline_table;\n}\n\nfunction toJSON(value: any): any {\n  return value && !isDate(value) && typeof value.toJSON === 'function' ? value.toJSON() : value;\n}\n","import { NodeType, AST } from './ast';\nimport traverse from './traverse';\nimport { Location } from './location';\nimport { SPACE } from './tokenizer';\n\nconst BY_NEW_LINE = /(\\r\\n|\\n)/g;\n\nexport default function toTOML(ast: AST, newline: string = '\\n'): string {\n  const lines: string[] = [];\n\n  traverse(ast, {\n    [NodeType.TableKey](node) {\n      const { start, end } = node.loc;\n\n      write(lines, { start, end: { line: start.line, column: start.column + 1 } }, '[');\n      write(lines, { start: { line: end.line, column: end.column - 1 }, end }, ']');\n    },\n    [NodeType.TableArrayKey](node) {\n      const { start, end } = node.loc;\n\n      write(lines, { start, end: { line: start.line, column: start.column + 2 } }, '[[');\n      write(lines, { start: { line: end.line, column: end.column - 2 }, end }, ']]');\n    },\n\n    [NodeType.KeyValue](node) {\n      const {\n        start: { line }\n      } = node.loc;\n      write(\n        lines,\n        { start: { line, column: node.equals }, end: { line, column: node.equals + 1 } },\n        '='\n      );\n    },\n    [NodeType.Key](node) {\n      write(lines, node.loc, node.raw);\n    },\n\n    [NodeType.String](node) {\n      write(lines, node.loc, node.raw);\n    },\n    [NodeType.Integer](node) {\n      write(lines, node.loc, node.raw);\n    },\n    [NodeType.Float](node) {\n      write(lines, node.loc, node.raw);\n    },\n    [NodeType.Boolean](node) {\n      write(lines, node.loc, node.value.toString());\n    },\n    [NodeType.DateTime](node) {\n      write(lines, node.loc, node.raw);\n    },\n\n    [NodeType.InlineArray](node) {\n      const { start, end } = node.loc;\n      write(lines, { start, end: { line: start.line, column: start.column + 1 } }, '[');\n      write(lines, { start: { line: end.line, column: end.column - 1 }, end }, ']');\n    },\n\n    [NodeType.InlineTable](node) {\n      const { start, end } = node.loc;\n      write(lines, { start, end: { line: start.line, column: start.column + 1 } }, '{');\n      write(lines, { start: { line: end.line, column: end.column - 1 }, end }, '}');\n    },\n    [NodeType.InlineItem](node) {\n      if (!node.comma) return;\n\n      const start = node.loc.end;\n      write(lines, { start, end: { line: start.line, column: start.column + 1 } }, ',');\n    },\n\n    [NodeType.Comment](node) {\n      write(lines, node.loc, node.raw);\n    }\n  });\n\n  return lines.join(newline) + newline;\n}\n\nfunction write(lines: string[], loc: Location, raw: string) {\n  const raw_lines = raw.split(BY_NEW_LINE);\n  const expected_lines = loc.end.line - loc.start.line + 1;\n\n  if (raw_lines.length !== expected_lines) {\n    throw new Error(\n      `Mismatch between location and raw string, expected ${expected_lines} lines for \"${raw}\"`\n    );\n  }\n\n  for (let i = loc.start.line; i <= loc.end.line; i++) {\n    const line = getLine(lines, i);\n    const is_start_line = i === loc.start.line;\n    const is_end_line = i === loc.end.line;\n\n    const before = is_start_line\n      ? line.substr(0, loc.start.column).padEnd(loc.start.column, SPACE)\n      : '';\n    const after = is_end_line ? line.substr(loc.end.column) : '';\n\n    lines[i - 1] = before + raw_lines[i - loc.start.line] + after;\n  }\n}\n\nfunction getLine(lines: string[], index: number): string {\n  if (!lines[index - 1]) {\n    for (let i = 0; i < index; i++) {\n      if (!lines[i]) lines[i] = '';\n    }\n  }\n\n  return lines[index - 1];\n}\n","import { Value, NodeType, Node, AST, isInlineTable } from './ast';\nimport traverse from './traverse';\nimport { last, blank, isDate, has } from './utils';\nimport ParseError from './parse-error';\n\nexport default function toJS(ast: AST, input: string = ''): any {\n  const result = blank();\n  const tables: Set<string> = new Set();\n  const table_arrays: Set<string> = new Set();\n  const defined: Set<string> = new Set();\n  let active: any = result;\n  let previous_active: any;\n  let skip = false;\n\n  traverse(ast, {\n    [NodeType.Table](node) {\n      const key = node.key.item.value;\n      try {\n        validateKey(result, key, node.type, { tables, table_arrays, defined });\n      } catch (err) {\n        throw new ParseError(input, node.key.loc.start, err.message);\n      }\n\n      const joined_key = joinKey(key);\n      tables.add(joined_key);\n      defined.add(joined_key);\n\n      active = ensureTable(result, key);\n    },\n\n    [NodeType.TableArray](node) {\n      const key = node.key.item.value;\n\n      try {\n        validateKey(result, key, node.type, { tables, table_arrays, defined });\n      } catch (err) {\n        throw new ParseError(input, node.key.loc.start, err.message);\n      }\n\n      const joined_key = joinKey(key);\n      table_arrays.add(joined_key);\n      defined.add(joined_key);\n\n      active = ensureTableArray(result, key);\n    },\n\n    [NodeType.KeyValue]: {\n      enter(node) {\n        if (skip) return;\n\n        const key = node.key.value;\n        try {\n          validateKey(active, key, node.type, { tables, table_arrays, defined });\n        } catch (err) {\n          throw new ParseError(input, node.key.loc.start, err.message);\n        }\n\n        const value = toValue(node.value);\n        const target = key.length > 1 ? ensureTable(active, key.slice(0, -1)) : active;\n\n        target[last(key)!] = value;\n        defined.add(joinKey(key));\n\n        if (isInlineTable(node.value)) {\n          previous_active = active;\n          active = value;\n        }\n      },\n      exit(node) {\n        if (isInlineTable(node.value)) {\n          active = previous_active;\n        }\n      }\n    },\n\n    [NodeType.InlineTable]: {\n      enter() {\n        // Handled by toValue\n        skip = true;\n      },\n      exit() {\n        skip = false;\n      }\n    }\n  });\n\n  return result;\n}\n\nexport function toValue(node: Value): any {\n  switch (node.type) {\n    case NodeType.InlineTable:\n      const result = blank();\n\n      node.items.forEach(({ item }) => {\n        const key = item.key.value;\n        const value = toValue(item.value);\n\n        const target = key.length > 1 ? ensureTable(result, key.slice(0, -1)) : result;\n        target[last(key)!] = value;\n      });\n\n      return result;\n\n    case NodeType.InlineArray:\n      return node.items.map(item => toValue(item.item as Value));\n\n    case NodeType.String:\n    case NodeType.Integer:\n    case NodeType.Float:\n    case NodeType.Boolean:\n    case NodeType.DateTime:\n      return node.value;\n\n    default:\n      throw new Error(`Unrecognized value type \"${(node as Node).type}\"`);\n  }\n}\n\nfunction validateKey(\n  object: any,\n  key: string[],\n  type: NodeType.Table | NodeType.TableArray | NodeType.KeyValue,\n  state: { tables: Set<string>; table_arrays: Set<string>; defined: Set<string> }\n) {\n  // 1. Cannot override primitive value\n  let parts: string[] = [];\n  let index = 0;\n  for (const part of key) {\n    parts.push(part);\n\n    if (!has(object, part)) return;\n    if (isPrimitive(object[part])) {\n      throw new Error(`Invalid key, a value has already been defined for ${parts.join('.')}`);\n    }\n\n    const joined_parts = joinKey(parts);\n    if (Array.isArray(object[part]) && !state.table_arrays.has(joined_parts)) {\n      throw new Error(`Invalid key, cannot add to a static array at ${joined_parts}`);\n    }\n\n    const next_is_last = index++ < key.length - 1;\n    object = Array.isArray(object[part]) && next_is_last ? last(object[part]) : object[part];\n  }\n\n  const joined_key = joinKey(key);\n\n  // 2. Cannot override table\n  if (object && type === NodeType.Table && state.defined.has(joined_key)) {\n    throw new Error(`Invalid key, a table has already been defined named ${joined_key}`);\n  }\n\n  // 3. Cannot add table array to static array or table\n  if (object && type === NodeType.TableArray && !state.table_arrays.has(joined_key)) {\n    throw new Error(`Invalid key, cannot add an array of tables to a table at ${joined_key}`);\n  }\n}\n\nfunction ensureTable(object: any, key: string[]): any {\n  const target = ensure(object, key.slice(0, -1));\n  const last_key = last(key)!;\n  if (!target[last_key]) {\n    target[last_key] = blank();\n  }\n\n  return target[last_key];\n}\n\nfunction ensureTableArray(object: any, key: string[]): any {\n  const target = ensure(object, key.slice(0, -1));\n  const last_key = last(key)!;\n  if (!target[last_key]) {\n    target[last_key] = [];\n  }\n\n  const next = blank();\n  target[last(key)!].push(next);\n\n  return next;\n}\n\nfunction ensure(object: any, keys: string[]): any {\n  return keys.reduce((active, subkey) => {\n    if (!active[subkey]) {\n      active[subkey] = blank();\n    }\n    return Array.isArray(active[subkey]) ? last(active[subkey]) : active[subkey];\n  }, object);\n}\n\nfunction isPrimitive(value: any) {\n  return typeof value !== 'object' && !isDate(value);\n}\n\nfunction joinKey(key: string[]): string {\n  return key.join('.');\n}\n","import { isObject, datesEqual, stableStringify, merge } from './utils';\nimport { Path } from './find-by-path';\n\nexport enum ChangeType {\n  Add = 'Add',\n  Edit = 'Edit',\n  Remove = 'Remove',\n  Move = 'Move',\n  Rename = 'Rename'\n}\n\nexport interface Add {\n  type: ChangeType.Add;\n  path: Path;\n}\nexport function isAdd(change: Change): change is Add {\n  return change.type === ChangeType.Add;\n}\n\nexport interface Edit {\n  type: ChangeType.Edit;\n  path: Path;\n}\nexport function isEdit(change: Change): change is Edit {\n  return change.type === ChangeType.Edit;\n}\n\nexport interface Remove {\n  type: ChangeType.Remove;\n  path: Path;\n}\nexport function isRemove(change: Change): change is Remove {\n  return change.type === ChangeType.Remove;\n}\n\nexport interface Move {\n  type: ChangeType.Move;\n  path: Path;\n  from: number;\n  to: number;\n}\nexport function isMove(change: Change): change is Move {\n  return change.type === ChangeType.Move;\n}\n\nexport interface Rename {\n  type: ChangeType.Rename;\n  path: Path;\n  from: string;\n  to: string;\n}\nexport function isRename(change: Change): change is Rename {\n  return change.type === ChangeType.Rename;\n}\n\nexport type Change = Add | Edit | Remove | Move | Rename;\n\nexport default function diff(before: any, after: any, path: Path = []): Change[] {\n  if (before === after || datesEqual(before, after)) {\n    return [];\n  }\n\n  if (Array.isArray(before) && Array.isArray(after)) {\n    return compareArrays(before, after, path);\n  } else if (isObject(before) && isObject(after)) {\n    return compareObjects(before, after, path);\n  } else {\n    return [\n      {\n        type: ChangeType.Edit,\n        path\n      }\n    ];\n  }\n}\n\nfunction compareObjects(before: any, after: any, path: Path = []): Change[] {\n  let changes: Change[] = [];\n\n  // 1. Get keys and stable values\n  const before_keys = Object.keys(before);\n  const before_stable = before_keys.map(key => stableStringify(before[key]));\n  const after_keys = Object.keys(after);\n  const after_stable = after_keys.map(key => stableStringify(after[key]));\n\n  // Check for rename by seeing if object is in both before and after\n  // and that key is no longer used in after\n  const isRename = (stable: string, search: string[]) => {\n    const index = search.indexOf(stable);\n    if (index < 0) return false;\n\n    const before_key = before_keys[before_stable.indexOf(stable)];\n    return !after_keys.includes(before_key);\n  };\n\n  // 2. Check for changes, rename, and removed\n  before_keys.forEach((key, index) => {\n    const sub_path = path.concat(key);\n    if (after_keys.includes(key)) {\n      merge(changes, diff(before[key], after[key], sub_path));\n    } else if (isRename(before_stable[index], after_stable)) {\n      const to = after_keys[after_stable.indexOf(before_stable[index])];\n      changes.push({\n        type: ChangeType.Rename,\n        path,\n        from: key,\n        to\n      });\n    } else {\n      changes.push({\n        type: ChangeType.Remove,\n        path: sub_path\n      });\n    }\n  });\n\n  // 3. Check for additions\n  after_keys.forEach((key, index) => {\n    if (!before_keys.includes(key) && !isRename(after_stable[index], before_stable)) {\n      changes.push({\n        type: ChangeType.Add,\n        path: path.concat(key)\n      });\n    }\n  });\n\n  return changes;\n}\n\nfunction compareArrays(before: any[], after: any[], path: Path = []): Change[] {\n  let changes: Change[] = [];\n\n  // 1. Convert arrays to stable objects\n  const before_stable = before.map(stableStringify);\n  const after_stable = after.map(stableStringify);\n\n  // 2. Step through after array making changes to before array as-needed\n  after_stable.forEach((value, index) => {\n    const overflow = index >= before_stable.length;\n\n    // Check if items are the same\n    if (!overflow && before_stable[index] === value) {\n      return;\n    }\n\n    // Check if item has been moved -> shift into place\n    const from = before_stable.indexOf(value, index + 1);\n    if (!overflow && from > -1) {\n      changes.push({\n        type: ChangeType.Move,\n        path,\n        from,\n        to: index\n      });\n\n      const move = before_stable.splice(from, 1);\n      before_stable.splice(index, 0, ...move);\n\n      return;\n    }\n\n    // Check if item is removed -> assume it's been edited and replace\n    const removed = !after_stable.includes(before_stable[index]);\n    if (!overflow && removed) {\n      merge(changes, diff(before[index], after[index], path.concat(index)));\n      before_stable[index] = value;\n\n      return;\n    }\n\n    // Add as new item and shift existing\n    changes.push({\n      type: ChangeType.Add,\n      path: path.concat(index)\n    });\n    before_stable.splice(index, 0, value);\n  });\n\n  // 3. Remove any remaining overflow items\n  for (let i = after_stable.length; i < before_stable.length; i++) {\n    changes.push({\n      type: ChangeType.Remove,\n      path: path.concat(i)\n    });\n  }\n\n  return changes;\n}\n","import { Node, isKeyValue, isTable, isTableArray, hasItems, isInlineItem, hasItem } from './ast';\nimport { arraysEqual, stableStringify } from './utils';\n\nexport type Path = Array<string | number>;\n\nexport default function findByPath(node: Node, path: Path): Node {\n  if (!path.length) return node;\n\n  if (isKeyValue(node)) {\n    return findByPath(node.value, path);\n  }\n\n  const indexes: { [key: string]: number } = {};\n  let found;\n  if (hasItems(node)) {\n    node.items.some((item, index) => {\n      try {\n        let key: Path = [];\n        if (isKeyValue(item)) {\n          key = item.key.value;\n        } else if (isTable(item)) {\n          key = item.key.item.value;\n        } else if (isTableArray(item)) {\n          key = item.key.item.value;\n\n          const key_string = stableStringify(key);\n          if (!indexes[key_string]) {\n            indexes[key_string] = 0;\n          }\n          const array_index = indexes[key_string]++;\n\n          key = key.concat(array_index);\n        } else if (isInlineItem(item) && isKeyValue(item.item)) {\n          key = item.item.key.value;\n        } else if (isInlineItem(item)) {\n          key = [index];\n        }\n\n        if (key.length && arraysEqual(key, path.slice(0, key.length))) {\n          found = findByPath(item, path.slice(key.length));\n          return true;\n        } else {\n          return false;\n        }\n      } catch (err) {\n        return false;\n      }\n    });\n  }\n\n  if (!found) {\n    throw new Error(`Could not find node at path ${path.join('.')}`);\n  }\n\n  return found;\n}\n\nexport function tryFindByPath(node: Node, path: Path): Node | undefined {\n  try {\n    return findByPath(node, path);\n  } catch (err) {}\n}\n\nexport function findParent(node: Node, path: Path): Node {\n  let parent_path = path;\n  let parent;\n  while (parent_path.length && !parent) {\n    parent_path = parent_path.slice(0, -1);\n    parent = tryFindByPath(node, parent_path);\n  }\n\n  if (!parent) {\n    throw new Error(`Count not find parent node for path ${path.join('.')}`);\n  }\n\n  return parent;\n}\n","import parseTOML from './parse-toml';\nimport parseJS from './parse-js';\nimport toTOML from './to-toml';\nimport toJS from './to-js';\nimport { Format } from './format';\n\nexport function parse(value: string): any {\n  return toJS(parseTOML(value), value);\n}\n\nexport function stringify(value: any, format?: Format): string {\n  const document = parseJS(value, format);\n  return toTOML(document.items);\n}\n\nexport { default as patch } from './patch';\n","import parseTOML from './parse-toml';\nimport parseJS from './parse-js';\nimport toJS from './to-js';\nimport toTOML from './to-toml';\nimport { Format } from './format';\nimport {\n  isKeyValue,\n  WithItems,\n  KeyValue,\n  isTable,\n  Node,\n  Document,\n  isDocument,\n  Block,\n  NodeType,\n  isTableArray,\n  isInlineArray,\n  hasItem,\n  InlineItem\n} from './ast';\nimport diff, { Change, isAdd, isEdit, isRemove, isMove, isRename } from './diff';\nimport findByPath, { tryFindByPath, findParent } from './find-by-path';\nimport { last, isInteger } from './utils';\nimport { insert, replace, remove, applyWrites } from './writer';\n\nexport default function patch(existing: string, updated: any, format?: Format): string {\n  const existing_ast = parseTOML(existing);\n  const items = [...existing_ast];\n\n  const existing_js = toJS(items);\n  const existing_document: Document = {\n    type: NodeType.Document,\n    loc: { start: { line: 1, column: 0 }, end: { line: 1, column: 0 } },\n    items\n  };\n\n  const updated_document = parseJS(updated, format);\n  const changes = diff(existing_js, updated);\n\n  const patched_document = applyChanges(existing_document, updated_document, changes);\n\n  return toTOML(patched_document.items);\n}\n\nfunction applyChanges(original: Document, updated: Document, changes: Change[]): Document {\n  // Potential Changes:\n  //\n  // Add: Add key-value to object, add item to array\n  // Edit: Change in value\n  // Remove: Remove key-value from object, remove item from array\n  // Move: Move item in array\n  // Rename: Rename key in key-value\n  //\n  // Special consideration, inline comments need to move as-needed\n\n  changes.forEach(change => {\n    if (isAdd(change)) {\n      const child = findByPath(updated, change.path);\n      const parent_path = change.path.slice(0, -1);\n      let index = last(change.path)! as number;\n\n      let is_table_array = isTableArray(child);\n      if (isInteger(index) && !parent_path.some(isInteger)) {\n        const sibling = tryFindByPath(original, parent_path.concat(0));\n        if (sibling && isTableArray(sibling)) {\n          is_table_array = true;\n        }\n      }\n\n      let parent: Node;\n      if (isTable(child)) {\n        parent = original;\n      } else if (is_table_array) {\n        parent = original;\n\n        // The index needs to be updated to top-level items\n        // to properly account for other items, comments, and nesting\n        const document = original as Document;\n        const before = tryFindByPath(document, parent_path.concat(index - 1)) as Block | undefined;\n        const after = tryFindByPath(document, parent_path.concat(index)) as Block | undefined;\n        if (after) {\n          index = document.items.indexOf(after);\n        } else if (before) {\n          index = document.items.indexOf(before) + 1;\n        } else {\n          index = document.items.length;\n        }\n      } else {\n        parent = findParent(original, change.path);\n        if (isKeyValue(parent)) parent = parent.value;\n      }\n\n      if (isTableArray(parent) || isInlineArray(parent) || isDocument(parent)) {\n        insert(original, parent, child, index);\n      } else {\n        insert(original, parent, child);\n      }\n    } else if (isEdit(change)) {\n      let existing = findByPath(original, change.path);\n      let replacement = findByPath(updated, change.path);\n      let parent;\n\n      if (isKeyValue(existing) && isKeyValue(replacement)) {\n        // Edit for key-value means value changes\n        parent = existing;\n        existing = existing.value;\n        replacement = replacement.value;\n      } else {\n        parent = findParent(original, change.path);\n      }\n\n      replace(original, parent, existing, replacement);\n    } else if (isRemove(change)) {\n      let parent = findParent(original, change.path);\n      if (isKeyValue(parent)) parent = parent.value;\n\n      const node = findByPath(original, change.path);\n\n      remove(original, parent, node);\n    } else if (isMove(change)) {\n      let parent = findByPath(original, change.path);\n      if (hasItem(parent)) parent = parent.item;\n      if (isKeyValue(parent)) parent = parent.value;\n\n      const node = (parent as WithItems).items[change.from];\n\n      remove(original, parent, node);\n      insert(original, parent, node, change.to);\n    } else if (isRename(change)) {\n      let parent = findByPath(original, change.path.concat(change.from)) as\n        | KeyValue\n        | InlineItem<KeyValue>;\n      let replacement = findByPath(updated, change.path.concat(change.to)) as\n        | KeyValue\n        | InlineItem<KeyValue>;\n\n      if (hasItem(parent)) parent = parent.item;\n      if (hasItem(replacement)) replacement = replacement.item;\n\n      replace(original, parent, parent.key, replacement.key);\n    }\n  });\n\n  applyWrites(original);\n  return original;\n}\n"],"names":["NodeType","TokenType","isDocument","node","type","Document","isTable","Table","isTableArray","TableArray","isKeyValue","KeyValue","isInlineArray","InlineArray","isInlineItem","InlineItem","isInlineTable","InlineTable","isComment","Comment","hasItems","hasItem","TableKey","isTableKey","TableArrayKey","isTableArrayKey","Cursor","[object Object]","iterator","this","index","value","undefined","done","peeked","result","next","Symbol","getSpan","location","lines","end","line","start","columns","column","findPosition","input","Array","isArray","findLines","findIndex","line_index","BY_NEW_LINE","indexes","match","exec","push","length","clonePosition","position","cloneLocation","ParseError","Error","message","error_message","substr","getLine","pointer","count","character","repeat","whitespace","super","IS_WHITESPACE","IS_NEW_LINE","DOUBLE_QUOTE","SINGLE_QUOTE","SPACE","ESCAPE","IS_VALID_LEADING_CHARACTER","tokenize","cursor","locate","createLocate","test","specialCharacter","Bracket","Curly","Equal","Comma","Dot","comment","multiline_char","checkThree","multiline","string","raw","loc","peek","quotes","Literal","double_quoted","single_quoted","isFinished","next_item","current","check","last","values","blank","Object","create","isInteger","isDate","prototype","toString","call","isObject","has","object","key","hasOwnProperty","pipe","fns","reduce","fn","stableStringify","keys","sort","map","JSON","stringify","join","merge","target","original_length","added_length","i","TRIPLE_DOUBLE_QUOTE","TRIPLE_SINGLE_QUOTE","LF","CRLF","IS_CRLF","IS_LF","IS_LEADING_NEW_LINE","IS_LINE_ENDING_BACKSLASH","parseString","startsWith","trim","trimLeadingWhitespace","lineEndingBackslash","escapeNewLines","unescape","escaped","json_escaped","replace","code_point","parseInt","as_string","String","fromCodePoint","parse","TRUE","FALSE","HAS_E","IS_DIVIDER","IS_INF","IS_NAN","IS_HEX","IS_OCTAL","IS_BINARY","IS_FULL_DATE","IS_FULL_TIME","parseTOML","tokens","walkBlock","is_table","item","Key","dot","before","after","items","table","equals","comments","walkValue","keyValue","Boolean","boolean","Date","local_date","toISOString","split","DateTime","datetime","Infinity","Number","Float","float","Integer","radix","integer","previous","comma","inline_item","inlineTable","inline_array","additional_comments","inlineArray","traverse","ast","visitor","traverseArray","array","parent","traverseNode","visit","enter","exit","enter_offsets","WeakMap","getEnter","root","set","get","exit_offsets","getExit","existing","replacement","indexOf","splice","shiftNode","existing_span","replacement_span","addOffset","insert","child","shift","offset","is_last","leading_comma","trailing_comma","last_comma","use_new_line","perLine","leading_lines","skip_comma","skip_bracket","child_span","insertInline","use_first_line","is_block","insertOnNewLine","previous_offset","delete","remove","removed_span","is_inline","previous_on_same_line","next_on_sameLine","keep_line","target_offsets","node_offsets","removed_offset","applyBracketSpacing","bracket_spacing","last_item","applyTrailingComma","trailing_commas","applyWrites","shiftStart","entering","shiftEnd","exiting","shiftLocation","start_line","key_offset","span","options","first_line_only","move","offsets","from","generateDocument","generateTable","table_key","keyValueToRaw","generateTableKey","generateTableArray","table_array_key","generateTableArrayKey","generateKeyValue","key_node","generateKey","IS_BARE_KEY","part","generateInlineItem","formatTopLevel","document","filter","is_inline_table","is_inline_array","forEach","key_value","formatTable","inline_array_item","table_array","inline_table_item","formatTableArray","formatEmptyLines","default_format","printWidth","trailingComma","bracketSpacing","parseJS","format","assign","toJSON","walkObject","formatPrintWidth","isString","generateString","generateInteger","isFloat","generateFloat","isBoolean","generateBoolean","generateDateTime","element","walkInlineArray","inline_table","walkInlineTable","toTOML","newline","write","raw_lines","expected_lines","is_start_line","is_end_line","padEnd","toJS","tables","Set","table_arrays","defined","previous_active","active","skip","validateKey","err","joined_key","joinKey","add","ensureTable","ensure","slice","last_key","ensureTableArray","toValue","state","parts","joined_parts","next_is_last","subkey","ChangeType","diff","path","b","a","changes","before_stable","after_stable","overflow","Move","to","removed","includes","concat","Add","Remove","compareArrays","before_keys","after_keys","isRename","stable","search","before_key","sub_path","Rename","compareObjects","Edit","findByPath","found","some","key_string","array_index","arraysEqual","tryFindByPath","findParent","parent_path","updated","existing_js","original","change","isAdd","is_table_array","sibling","isEdit","isRemove","isMove","applyChanges"],"mappings":"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"}