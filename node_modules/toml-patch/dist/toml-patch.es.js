//! toml-patch v0.2.3 - https://github.com/timhall/toml-patch - @license: MIT
var NodeType;
(function (NodeType) {
    NodeType["Document"] = "Document";
    NodeType["Table"] = "Table";
    NodeType["TableKey"] = "TableKey";
    NodeType["TableArray"] = "TableArray";
    NodeType["TableArrayKey"] = "TableArrayKey";
    NodeType["KeyValue"] = "KeyValue";
    NodeType["Key"] = "Key";
    NodeType["String"] = "String";
    NodeType["Integer"] = "Integer";
    NodeType["Float"] = "Float";
    NodeType["Boolean"] = "Boolean";
    NodeType["DateTime"] = "DateTime";
    NodeType["InlineArray"] = "InlineArray";
    NodeType["InlineItem"] = "InlineItem";
    NodeType["InlineTable"] = "InlineTable";
    NodeType["Comment"] = "Comment";
})(NodeType || (NodeType = {}));
function isDocument(node) {
    return node.type === NodeType.Document;
}
function isTable(node) {
    return node.type === NodeType.Table;
}
function isTableKey(node) {
    return node.type === NodeType.TableKey;
}
function isTableArray(node) {
    return node.type === NodeType.TableArray;
}
function isTableArrayKey(node) {
    return node.type === NodeType.TableArrayKey;
}
function isKeyValue(node) {
    return node.type === NodeType.KeyValue;
}
function isInlineArray(node) {
    return node.type === NodeType.InlineArray;
}
function isInlineItem(node) {
    return node.type === NodeType.InlineItem;
}
function isInlineTable(node) {
    return node.type === NodeType.InlineTable;
}
function isComment(node) {
    return node.type === NodeType.Comment;
}
function hasItems(node) {
    return (isDocument(node) ||
        isTable(node) ||
        isTableArray(node) ||
        isInlineTable(node) ||
        isInlineArray(node));
}
function hasItem(node) {
    return isTableKey(node) || isTableArrayKey(node) || isInlineItem(node);
}
function isBlock(node) {
    return isKeyValue(node) || isTable(node) || isTableArray(node) || isComment(node);
}

function iterator(value) {
    return value[Symbol.iterator]();
}
class Cursor {
    constructor(iterator) {
        this.iterator = iterator;
        this.index = -1;
        this.value = undefined;
        this.done = false;
        this.peeked = null;
    }
    next() {
        if (this.done)
            return done();
        const result = this.peeked || this.iterator.next();
        this.index += 1;
        this.value = result.value;
        this.done = result.done;
        this.peeked = null;
        return result;
    }
    peek() {
        if (this.done)
            return done();
        if (this.peeked)
            return this.peeked;
        this.peeked = this.iterator.next();
        return this.peeked;
    }
    [Symbol.iterator]() {
        return this;
    }
}
function done() {
    return { value: undefined, done: true };
}

function getSpan(location) {
    return {
        lines: location.end.line - location.start.line + 1,
        columns: location.end.column - location.start.column
    };
}
function createLocate(input) {
    const lines = findLines(input);
    return (start, end) => {
        return {
            start: findPosition(lines, start),
            end: findPosition(lines, end)
        };
    };
}
function findPosition(input, index) {
    // abc\ndef\ng
    // 0123 4567 8
    //      012
    //           0
    //
    // lines = [3, 7, 9]
    //
    // c = 2: 0 -> 1, 2 - (undefined + 1 || 0) = 2
    //     3: 0 -> 1, 3 - (undefined + 1 || 0) = 3
    // e = 5: 1 -> 2, 5 - (3 + 1 || 0) = 1
    // g = 8: 2 -> 3, 8 - (7 + 1 || 0) = 0
    const lines = Array.isArray(input) ? input : findLines(input);
    const line = lines.findIndex(line_index => line_index >= index) + 1;
    const column = index - (lines[line - 2] + 1 || 0);
    return { line, column };
}
function getLine(input, position) {
    const lines = findLines(input);
    const start = lines[position.line - 2] || 0;
    const end = lines[position.line - 1] || input.length;
    return input.substr(start, end - start);
}
function findLines(input) {
    // exec is stateful, so create new regexp each time
    const BY_NEW_LINE = /[\r\n|\n]/g;
    const indexes = [];
    let match;
    while ((match = BY_NEW_LINE.exec(input)) != null) {
        indexes.push(match.index);
    }
    indexes.push(input.length + 1);
    return indexes;
}
function clonePosition(position) {
    return { line: position.line, column: position.column };
}
function cloneLocation(location) {
    return { start: clonePosition(location.start), end: clonePosition(location.end) };
}
function zero() {
    return { line: 1, column: 0 };
}

class ParseError extends Error {
    constructor(input, position, message) {
        let error_message = `Error parsing TOML (${position.line}, ${position.column + 1}):\n`;
        if (input) {
            const line = getLine(input, position);
            const pointer = `${whitespace(position.column)}^`;
            if (line)
                error_message += `${line}\n${pointer}\n`;
        }
        error_message += message;
        super(error_message);
        this.line = position.line;
        this.column = position.column;
    }
}
function whitespace(count, character = ' ') {
    return character.repeat(count);
}

var TokenType;
(function (TokenType) {
    TokenType["Bracket"] = "Bracket";
    TokenType["Curly"] = "Curly";
    TokenType["Equal"] = "Equal";
    TokenType["Comma"] = "Comma";
    TokenType["Dot"] = "Dot";
    TokenType["Comment"] = "Comment";
    TokenType["Literal"] = "Literal";
})(TokenType || (TokenType = {}));
const IS_WHITESPACE = /\s/;
const IS_NEW_LINE = /(\r\n|\n)/;
const DOUBLE_QUOTE = `"`;
const SINGLE_QUOTE = `'`;
const SPACE = ' ';
const ESCAPE = '\\';
const IS_VALID_LEADING_CHARACTER = /[\w,\d,\",\',\+,\-,\_]/;
function* tokenize(input) {
    const cursor = new Cursor(iterator(input));
    cursor.next();
    const locate = createLocate(input);
    while (!cursor.done) {
        if (IS_WHITESPACE.test(cursor.value)) ;
        else if (cursor.value === '[' || cursor.value === ']') {
            // Handle special characters: [, ], {, }, =, comma
            yield specialCharacter(cursor, locate, TokenType.Bracket);
        }
        else if (cursor.value === '{' || cursor.value === '}') {
            yield specialCharacter(cursor, locate, TokenType.Curly);
        }
        else if (cursor.value === '=') {
            yield specialCharacter(cursor, locate, TokenType.Equal);
        }
        else if (cursor.value === ',') {
            yield specialCharacter(cursor, locate, TokenType.Comma);
        }
        else if (cursor.value === '.') {
            yield specialCharacter(cursor, locate, TokenType.Dot);
        }
        else if (cursor.value === '#') {
            // Handle comments = # -> EOL
            yield comment(cursor, locate);
        }
        else {
            const multiline_char = checkThree(input, cursor.index, SINGLE_QUOTE) ||
                checkThree(input, cursor.index, DOUBLE_QUOTE);
            if (multiline_char) {
                // Multi-line literals or strings = no escaping
                yield multiline(cursor, locate, multiline_char, input);
            }
            else {
                yield string(cursor, locate, input);
            }
        }
        cursor.next();
    }
}
function specialCharacter(cursor, locate, type) {
    return { type, raw: cursor.value, loc: locate(cursor.index, cursor.index + 1) };
}
function comment(cursor, locate) {
    const start = cursor.index;
    let raw = cursor.value;
    while (!cursor.peek().done && !IS_NEW_LINE.test(cursor.peek().value)) {
        cursor.next();
        raw += cursor.value;
    }
    // Early exit is ok for comment, no closing conditions
    return {
        type: TokenType.Comment,
        raw,
        loc: locate(start, cursor.index + 1)
    };
}
function multiline(cursor, locate, multiline_char, input) {
    const start = cursor.index;
    let quotes = multiline_char + multiline_char + multiline_char;
    let raw = quotes;
    // Skip over quotes
    cursor.next();
    cursor.next();
    cursor.next();
    while (!cursor.done && !checkThree(input, cursor.index, multiline_char)) {
        raw += cursor.value;
        cursor.next();
    }
    if (cursor.done) {
        throw new ParseError(input, findPosition(input, cursor.index), `Expected close of multiline string with ${quotes}, reached end of file`);
    }
    raw += quotes;
    cursor.next();
    cursor.next();
    return {
        type: TokenType.Literal,
        raw,
        loc: locate(start, cursor.index + 1)
    };
}
function string(cursor, locate, input) {
    // Remaining possibilities: keys, strings, literals, integer, float, boolean
    //
    // Special cases:
    // "..." -> quoted
    // '...' -> quoted
    // "...".'...' -> bare
    // 0000-00-00 00:00:00 -> bare
    //
    // See https://github.com/toml-lang/toml#offset-date-time
    //
    // | For the sake of readability, you may replace the T delimiter between date and time with a space (as permitted by RFC 3339 section 5.6).
    // | `odt4 = 1979-05-27 07:32:00Z`
    //
    // From RFC 3339:
    //
    // | NOTE: ISO 8601 defines date and time separated by "T".
    // | Applications using this syntax may choose, for the sake of
    // | readability, to specify a full-date and full-time separated by
    // | (say) a space character.
    // First, check for invalid characters
    if (!IS_VALID_LEADING_CHARACTER.test(cursor.value)) {
        throw new ParseError(input, findPosition(input, cursor.index), `Unsupported character "${cursor.value}". Expected ALPHANUMERIC, ", ', +, -, or _`);
    }
    const start = cursor.index;
    let raw = cursor.value;
    let double_quoted = cursor.value === DOUBLE_QUOTE;
    let single_quoted = cursor.value === SINGLE_QUOTE;
    const isFinished = (cursor) => {
        if (cursor.peek().done)
            return true;
        const next_item = cursor.peek().value;
        return (!(double_quoted || single_quoted) &&
            (IS_WHITESPACE.test(next_item) ||
                next_item === ',' ||
                next_item === '.' ||
                next_item === ']' ||
                next_item === '}' ||
                next_item === '='));
    };
    while (!cursor.done && !isFinished(cursor)) {
        cursor.next();
        if (cursor.value === DOUBLE_QUOTE)
            double_quoted = !double_quoted;
        if (cursor.value === SINGLE_QUOTE && !double_quoted)
            single_quoted = !single_quoted;
        raw += cursor.value;
        if (cursor.peek().done)
            break;
        let next_item = cursor.peek().value;
        // If next character is escape and currently double-quoted,
        // check for escaped quote
        if (double_quoted && cursor.value === ESCAPE) {
            if (next_item === DOUBLE_QUOTE) {
                raw += DOUBLE_QUOTE;
                cursor.next();
            }
            else if (next_item === ESCAPE) {
                raw += ESCAPE;
                cursor.next();
            }
        }
    }
    if (double_quoted || single_quoted) {
        throw new ParseError(input, findPosition(input, start), `Expected close of string with ${double_quoted ? DOUBLE_QUOTE : SINGLE_QUOTE}`);
    }
    return {
        type: TokenType.Literal,
        raw,
        loc: locate(start, cursor.index + 1)
    };
}
function checkThree(input, current, check) {
    return (input[current] === check &&
        input[current + 1] === check &&
        input[current + 2] === check &&
        check);
}

function last(values) {
    return values[values.length - 1];
}
function blank() {
    return Object.create(null);
}
function isString(value) {
    return typeof value === 'string';
}
function isInteger(value) {
    return typeof value === 'number' && value % 1 === 0;
}
function isFloat(value) {
    return typeof value === 'number' && !isInteger(value);
}
function isBoolean(value) {
    return typeof value === 'boolean';
}
function isDate(value) {
    return Object.prototype.toString.call(value) === '[object Date]';
}
function isObject(value) {
    return value && typeof value === 'object' && !isDate(value) && !Array.isArray(value);
}
function isIterable(value) {
    return value != null && typeof value[Symbol.iterator] === 'function';
}
function has(object, key) {
    return Object.prototype.hasOwnProperty.call(object, key);
}
function arraysEqual(a, b) {
    if (a.length !== b.length)
        return false;
    for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i])
            return false;
    }
    return true;
}
function datesEqual(a, b) {
    return isDate(a) && isDate(b) && a.toISOString() === b.toISOString();
}
function pipe(value, ...fns) {
    return fns.reduce((value, fn) => fn(value), value);
}
function stableStringify(object) {
    if (isObject(object)) {
        const key_values = Object.keys(object)
            .sort()
            .map(key => `${JSON.stringify(key)}:${stableStringify(object[key])}`);
        return `{${key_values.join(',')}}`;
    }
    else if (Array.isArray(object)) {
        return `[${object.map(stableStringify).join(',')}]`;
    }
    else {
        return JSON.stringify(object);
    }
}
function merge(target, values) {
    // __mutating__: merge values into target
    // Reference: https://dev.to/uilicious/javascript-array-push-is-945x-faster-than-array-concat-1oki
    const original_length = target.length;
    const added_length = values.length;
    target.length = original_length + added_length;
    for (let i = 0; i < added_length; i++) {
        target[original_length + i] = values[i];
    }
}

const TRIPLE_DOUBLE_QUOTE = `"""`;
const TRIPLE_SINGLE_QUOTE = `'''`;
const LF = '\\n';
const CRLF = '\\r\\n';
const IS_CRLF = /\r\n/g;
const IS_LF = /\n/g;
const IS_LEADING_NEW_LINE = /^(\r\n|\n)/;
const IS_LINE_ENDING_BACKSLASH = /\\\s*[\n\r\n]\s*/g;
function parseString(raw) {
    if (raw.startsWith(TRIPLE_SINGLE_QUOTE)) {
        return pipe(trim(raw, 3), trimLeadingWhitespace);
    }
    else if (raw.startsWith(SINGLE_QUOTE)) {
        return trim(raw, 1);
    }
    else if (raw.startsWith(TRIPLE_DOUBLE_QUOTE)) {
        return pipe(trim(raw, 3), trimLeadingWhitespace, lineEndingBackslash, escapeNewLines, unescape);
    }
    else if (raw.startsWith(DOUBLE_QUOTE)) {
        return pipe(trim(raw, 1), unescape);
    }
    else {
        return raw;
    }
}
function unescape(escaped) {
    // JSON.parse handles everything except \UXXXXXXXX
    // replace those instances with code point, escape that, and then parse
    const LARGE_UNICODE = /\\U[a-fA-F0-9]{8}/g;
    const json_escaped = escaped.replace(LARGE_UNICODE, value => {
        const code_point = parseInt(value.replace('\\U', ''), 16);
        const as_string = String.fromCodePoint(code_point);
        return trim(JSON.stringify(as_string), 1);
    });
    return JSON.parse(`"${json_escaped}"`);
}
function trim(value, count) {
    return value.substr(count, value.length - count * 2);
}
function trimLeadingWhitespace(value) {
    return IS_LEADING_NEW_LINE.test(value) ? value.substr(1) : value;
}
function escapeNewLines(value) {
    return value.replace(IS_CRLF, CRLF).replace(IS_LF, LF);
}
function lineEndingBackslash(value) {
    return value.replace(IS_LINE_ENDING_BACKSLASH, '');
}

const TRUE = 'true';
const FALSE = 'false';
const HAS_E = /e/i;
const IS_DIVIDER = /\_/g;
const IS_INF = /inf/;
const IS_NAN = /nan/;
const IS_HEX = /^0x/;
const IS_OCTAL = /^0o/;
const IS_BINARY = /^0b/;
const IS_FULL_DATE = /(\d{4})-(\d{2})-(\d{2})/;
const IS_FULL_TIME = /(\d{2}):(\d{2}):(\d{2})/;
function* parseTOML(input) {
    const tokens = tokenize(input);
    const cursor = new Cursor(tokens);
    while (!cursor.next().done) {
        yield* walkBlock(cursor, input);
    }
}
function* walkBlock(cursor, input) {
    if (cursor.value.type === TokenType.Comment) {
        yield comment$1(cursor);
    }
    else if (cursor.value.type === TokenType.Bracket) {
        yield table(cursor, input);
    }
    else if (cursor.value.type === TokenType.Literal) {
        yield* keyValue(cursor, input);
    }
    else {
        throw new ParseError(input, cursor.value.loc.start, `Unexpected token "${cursor.value.type}". Expected Comment, Bracket, or String`);
    }
}
function* walkValue(cursor, input) {
    if (cursor.value.type === TokenType.Literal) {
        if (cursor.value.raw[0] === DOUBLE_QUOTE || cursor.value.raw[0] === SINGLE_QUOTE) {
            yield string$1(cursor);
        }
        else if (cursor.value.raw === TRUE || cursor.value.raw === FALSE) {
            yield boolean(cursor);
        }
        else if (IS_FULL_DATE.test(cursor.value.raw) || IS_FULL_TIME.test(cursor.value.raw)) {
            yield datetime(cursor, input);
        }
        else if ((!cursor.peek().done && cursor.peek().value.type === TokenType.Dot) ||
            IS_INF.test(cursor.value.raw) ||
            IS_NAN.test(cursor.value.raw) ||
            (HAS_E.test(cursor.value.raw) && !IS_HEX.test(cursor.value.raw))) {
            yield float(cursor, input);
        }
        else {
            yield integer(cursor);
        }
    }
    else if (cursor.value.type === TokenType.Curly) {
        yield inlineTable(cursor, input);
    }
    else if (cursor.value.type === TokenType.Bracket) {
        const [inline_array, comments] = inlineArray(cursor, input);
        yield inline_array;
        yield* comments;
    }
    else {
        throw new ParseError(input, cursor.value.loc.start, `Unrecognized token type "${cursor.value.type}". Expected String, Curly, or Bracket`);
    }
}
function comment$1(cursor) {
    // # line comment
    // ^------------^ Comment
    return {
        type: NodeType.Comment,
        loc: cursor.value.loc,
        raw: cursor.value.raw
    };
}
function table(cursor, input) {
    // Table or TableArray
    //
    // [ key ]
    // ^-----^    TableKey
    //   ^-^      Key
    //
    // [[ key ]]
    // ^ ------^  TableArrayKey
    //    ^-^     Key
    //
    // a = "b"  < Items
    // # c      |
    // d = "f"  <
    //
    // ...
    const type = !cursor.peek().done && cursor.peek().value.type === TokenType.Bracket
        ? NodeType.TableArray
        : NodeType.Table;
    const is_table = type === NodeType.Table;
    if (is_table && cursor.value.raw !== '[') {
        throw new ParseError(input, cursor.value.loc.start, `Expected table opening "[", found ${cursor.value.raw}`);
    }
    if (!is_table && (cursor.value.raw !== '[' || cursor.peek().value.raw !== '[')) {
        throw new ParseError(input, cursor.value.loc.start, `Expected array of tables opening "[[", found ${cursor.value.raw + cursor.peek().value.raw}`);
    }
    // Set start location from opening tag
    const key = is_table
        ? {
            type: NodeType.TableKey,
            loc: cursor.value.loc
        }
        : {
            type: NodeType.TableArrayKey,
            loc: cursor.value.loc
        };
    // Skip to cursor.value for key value
    cursor.next();
    if (type === NodeType.TableArray)
        cursor.next();
    if (cursor.done) {
        throw new ParseError(input, key.loc.start, `Expected table key, reached end of file`);
    }
    key.item = {
        type: NodeType.Key,
        loc: cloneLocation(cursor.value.loc),
        raw: cursor.value.raw,
        value: [parseString(cursor.value.raw)]
    };
    while (!cursor.peek().done && cursor.peek().value.type === TokenType.Dot) {
        cursor.next();
        const dot = cursor.value;
        cursor.next();
        const before = ' '.repeat(dot.loc.start.column - key.item.loc.end.column);
        const after = ' '.repeat(cursor.value.loc.start.column - dot.loc.end.column);
        key.item.loc.end = cursor.value.loc.end;
        key.item.raw += `${before}.${after}${cursor.value.raw}`;
        key.item.value.push(parseString(cursor.value.raw));
    }
    cursor.next();
    if (is_table && (cursor.done || cursor.value.raw !== ']')) {
        throw new ParseError(input, cursor.done ? key.item.loc.end : cursor.value.loc.start, `Expected table closing "]", found ${cursor.done ? 'end of file' : cursor.value.raw}`);
    }
    if (!is_table &&
        (cursor.done ||
            cursor.peek().done ||
            cursor.value.raw !== ']' ||
            cursor.peek().value.raw !== ']')) {
        throw new ParseError(input, cursor.done || cursor.peek().done ? key.item.loc.end : cursor.value.loc.start, `Expected array of tables closing "]]", found ${cursor.done || cursor.peek().done
            ? 'end of file'
            : cursor.value.raw + cursor.peek().value.raw}`);
    }
    // Set end location from closing tag
    if (!is_table)
        cursor.next();
    key.loc.end = cursor.value.loc.end;
    // Add child items
    let items = [];
    while (!cursor.peek().done && cursor.peek().value.type !== TokenType.Bracket) {
        cursor.next();
        merge(items, [...walkBlock(cursor, input)]);
    }
    return {
        type: is_table ? NodeType.Table : NodeType.TableArray,
        loc: {
            start: clonePosition(key.loc.start),
            end: items.length
                ? clonePosition(items[items.length - 1].loc.end)
                : clonePosition(key.loc.end)
        },
        key: key,
        items
    };
}
function keyValue(cursor, input) {
    // 3. KeyValue
    //
    // key = value
    // ^-^          key
    //     ^        equals
    //       ^---^  value
    const key = {
        type: NodeType.Key,
        loc: cloneLocation(cursor.value.loc),
        raw: cursor.value.raw,
        value: [parseString(cursor.value.raw)]
    };
    while (!cursor.peek().done && cursor.peek().value.type === TokenType.Dot) {
        cursor.next();
        cursor.next();
        key.loc.end = cursor.value.loc.end;
        key.raw += `.${cursor.value.raw}`;
        key.value.push(parseString(cursor.value.raw));
    }
    cursor.next();
    if (cursor.done || cursor.value.type !== TokenType.Equal) {
        throw new ParseError(input, cursor.done ? key.loc.end : cursor.value.loc.start, `Expected "=" for key-value, found ${cursor.done ? 'end of file' : cursor.value.raw}`);
    }
    const equals = cursor.value.loc.start.column;
    cursor.next();
    if (cursor.done) {
        throw new ParseError(input, key.loc.start, `Expected value for key-value, reached end of file`);
    }
    const [value, ...comments] = walkValue(cursor, input);
    return [
        {
            type: NodeType.KeyValue,
            key,
            value: value,
            loc: {
                start: clonePosition(key.loc.start),
                end: clonePosition(value.loc.end)
            },
            equals
        },
        ...comments
    ];
}
function string$1(cursor) {
    return {
        type: NodeType.String,
        loc: cursor.value.loc,
        raw: cursor.value.raw,
        value: parseString(cursor.value.raw)
    };
}
function boolean(cursor) {
    return {
        type: NodeType.Boolean,
        loc: cursor.value.loc,
        value: cursor.value.raw === TRUE
    };
}
function datetime(cursor, input) {
    // Possible values:
    //
    // Offset Date-Time
    // | odt1 = 1979-05-27T07:32:00Z
    // | odt2 = 1979-05-27T00:32:00-07:00
    // | odt3 = 1979-05-27T00:32:00.999999-07:00
    // | odt4 = 1979-05-27 07:32:00Z
    //
    // Local Date-Time
    // | ldt1 = 1979-05-27T07:32:00
    // | ldt2 = 1979-05-27T00:32:00.999999
    //
    // Local Date
    // | ld1 = 1979-05-27
    //
    // Local Time
    // | lt1 = 07:32:00
    // | lt2 = 00:32:00.999999
    let loc = cursor.value.loc;
    let raw = cursor.value.raw;
    let value;
    // If next token is string,
    // check if raw is full date and following is full time
    if (!cursor.peek().done &&
        cursor.peek().value.type === TokenType.Literal &&
        IS_FULL_DATE.test(raw) &&
        IS_FULL_TIME.test(cursor.peek().value.raw)) {
        const start = loc.start;
        cursor.next();
        loc = { start, end: cursor.value.loc.end };
        raw += ` ${cursor.value.raw}`;
    }
    if (!cursor.peek().done && cursor.peek().value.type === TokenType.Dot) {
        const start = loc.start;
        cursor.next();
        if (cursor.peek().done || cursor.peek().value.type !== TokenType.Literal) {
            throw new ParseError(input, cursor.value.loc.end, `Expected fractional value for DateTime`);
        }
        cursor.next();
        loc = { start, end: cursor.value.loc.end };
        raw += `.${cursor.value.raw}`;
    }
    if (!IS_FULL_DATE.test(raw)) {
        // For local time, use local ISO date
        const [local_date] = new Date().toISOString().split('T');
        value = new Date(`${local_date}T${raw}`);
    }
    else {
        value = new Date(raw.replace(' ', 'T'));
    }
    return {
        type: NodeType.DateTime,
        loc,
        raw,
        value
    };
}
function float(cursor, input) {
    let loc = cursor.value.loc;
    let raw = cursor.value.raw;
    let value;
    if (IS_INF.test(raw)) {
        value = raw === '-inf' ? -Infinity : Infinity;
    }
    else if (IS_NAN.test(raw)) {
        value = raw === '-nan' ? -NaN : NaN;
    }
    else if (!cursor.peek().done && cursor.peek().value.type === TokenType.Dot) {
        const start = loc.start;
        // From spec:
        // | A fractional part is a decimal point followed by one or more digits.
        //
        // -> Don't have to handle "4." (i.e. nothing behind decimal place)
        cursor.next();
        if (cursor.peek().done || cursor.peek().value.type !== TokenType.Literal) {
            throw new ParseError(input, cursor.value.loc.end, `Expected fraction value for Float`);
        }
        cursor.next();
        raw += `.${cursor.value.raw}`;
        loc = { start, end: cursor.value.loc.end };
        value = Number(raw.replace(IS_DIVIDER, ''));
    }
    else {
        value = Number(raw.replace(IS_DIVIDER, ''));
    }
    return { type: NodeType.Float, loc, raw, value };
}
function integer(cursor) {
    // > Integer values -0 and +0 are valid and identical to an unprefixed zero
    if (cursor.value.raw === '-0' || cursor.value.raw === '+0') {
        return {
            type: NodeType.Integer,
            loc: cursor.value.loc,
            raw: cursor.value.raw,
            value: 0
        };
    }
    let radix = 10;
    if (IS_HEX.test(cursor.value.raw)) {
        radix = 16;
    }
    else if (IS_OCTAL.test(cursor.value.raw)) {
        radix = 8;
    }
    else if (IS_BINARY.test(cursor.value.raw)) {
        radix = 2;
    }
    const value = parseInt(cursor
        .value.raw.replace(IS_DIVIDER, '')
        .replace(IS_OCTAL, '')
        .replace(IS_BINARY, ''), radix);
    return {
        type: NodeType.Integer,
        loc: cursor.value.loc,
        raw: cursor.value.raw,
        value
    };
}
function inlineTable(cursor, input) {
    if (cursor.value.raw !== '{') {
        throw new ParseError(input, cursor.value.loc.start, `Expected "{" for inline table, found ${cursor.value.raw}`);
    }
    // 6. InlineTable
    const value = {
        type: NodeType.InlineTable,
        loc: cloneLocation(cursor.value.loc),
        items: []
    };
    cursor.next();
    while (!cursor.done &&
        !(cursor.value.type === TokenType.Curly && cursor.value.raw === '}')) {
        if (cursor.value.type === TokenType.Comma) {
            const previous = value.items[value.items.length - 1];
            if (!previous) {
                throw new ParseError(input, cursor.value.loc.start, 'Found "," without previous value in inline table');
            }
            previous.comma = true;
            previous.loc.end = cursor.value.loc.start;
            cursor.next();
            continue;
        }
        const [item] = walkBlock(cursor, input);
        if (item.type !== NodeType.KeyValue) {
            throw new ParseError(input, cursor.value.loc.start, `Only key-values are supported in inline tables, found ${item.type}`);
        }
        const inline_item = {
            type: NodeType.InlineItem,
            loc: cloneLocation(item.loc),
            item,
            comma: false
        };
        value.items.push(inline_item);
        cursor.next();
    }
    if (cursor.done ||
        cursor.value.type !== TokenType.Curly ||
        cursor.value.raw !== '}') {
        throw new ParseError(input, cursor.done ? value.loc.start : cursor.value.loc.start, `Expected "}", found ${cursor.done ? 'end of file' : cursor.value.raw}`);
    }
    value.loc.end = cursor.value.loc.end;
    return value;
}
function inlineArray(cursor, input) {
    // 7. InlineArray
    if (cursor.value.raw !== '[') {
        throw new ParseError(input, cursor.value.loc.start, `Expected "[" for inline array, found ${cursor.value.raw}`);
    }
    const value = {
        type: NodeType.InlineArray,
        loc: cloneLocation(cursor.value.loc),
        items: []
    };
    let comments = [];
    cursor.next();
    while (!cursor.done &&
        !(cursor.value.type === TokenType.Bracket && cursor.value.raw === ']')) {
        if (cursor.value.type === TokenType.Comma) {
            const previous = value.items[value.items.length - 1];
            if (!previous) {
                throw new ParseError(input, cursor.value.loc.start, 'Found "," without previous value for inline array');
            }
            previous.comma = true;
            previous.loc.end = cursor.value.loc.start;
        }
        else if (cursor.value.type === TokenType.Comment) {
            comments.push(comment$1(cursor));
        }
        else {
            const [item, ...additional_comments] = walkValue(cursor, input);
            const inline_item = {
                type: NodeType.InlineItem,
                loc: cloneLocation(item.loc),
                item,
                comma: false
            };
            value.items.push(inline_item);
            merge(comments, additional_comments);
        }
        cursor.next();
    }
    if (cursor.done ||
        cursor.value.type !== TokenType.Bracket ||
        cursor.value.raw !== ']') {
        throw new ParseError(input, cursor.done ? value.loc.start : cursor.value.loc.start, `Expected "]", found ${cursor.done ? 'end of file' : cursor.value.raw}`);
    }
    value.loc.end = cursor.value.loc.end;
    return [value, comments];
}

function traverse(ast, visitor) {
    if (isIterable(ast)) {
        traverseArray(ast, null);
    }
    else {
        traverseNode(ast, null);
    }
    function traverseArray(array, parent) {
        for (const node of array) {
            traverseNode(node, parent);
        }
    }
    function traverseNode(node, parent) {
        const visit = visitor[node.type];
        if (visit && typeof visit === 'function') {
            visit(node, parent);
        }
        if (visit && visit.enter) {
            visit.enter(node, parent);
        }
        switch (node.type) {
            case NodeType.Document:
                traverseArray(node.items, node);
                break;
            case NodeType.Table:
                traverseNode(node.key, node);
                traverseArray(node.items, node);
                break;
            case NodeType.TableKey:
                traverseNode(node.item, node);
                break;
            case NodeType.TableArray:
                traverseNode(node.key, node);
                traverseArray(node.items, node);
                break;
            case NodeType.TableArrayKey:
                traverseNode(node.item, node);
                break;
            case NodeType.KeyValue:
                traverseNode(node.key, node);
                traverseNode(node.value, node);
                break;
            case NodeType.InlineArray:
                traverseArray(node.items, node);
                break;
            case NodeType.InlineItem:
                traverseNode(node.item, node);
                break;
            case NodeType.InlineTable:
                traverseArray(node.items, node);
                break;
            case NodeType.Key:
            case NodeType.String:
            case NodeType.Integer:
            case NodeType.Float:
            case NodeType.Boolean:
            case NodeType.DateTime:
            case NodeType.Comment:
                break;
            default:
                throw new Error(`Unrecognized node type "${node.type}"`);
        }
        if (visit && visit.exit) {
            visit.exit(node, parent);
        }
    }
}

const enter_offsets = new WeakMap();
const getEnter = (root) => {
    if (!enter_offsets.has(root)) {
        enter_offsets.set(root, new WeakMap());
    }
    return enter_offsets.get(root);
};
const exit_offsets = new WeakMap();
const getExit = (root) => {
    if (!exit_offsets.has(root)) {
        exit_offsets.set(root, new WeakMap());
    }
    return exit_offsets.get(root);
};
function replace(root, parent, existing, replacement) {
    // First, replace existing node
    // (by index for items, item, or key/value)
    if (hasItems(parent)) {
        const index = parent.items.indexOf(existing);
        if (index < 0)
            throw new Error(`Could not find existing item in parent node for replace`);
        parent.items.splice(index, 1, replacement);
    }
    else if (hasItem(parent)) {
        parent.item = replacement;
    }
    else if (isKeyValue(parent)) {
        if (parent.key === existing) {
            parent.key = replacement;
        }
        else {
            parent.value = replacement;
        }
    }
    else {
        throw new Error(`Unsupported parent type "${parent.type}" for replace`);
    }
    // Shift the replacement node into the same start position as existing
    const shift = {
        lines: existing.loc.start.line - replacement.loc.start.line,
        columns: existing.loc.start.column - replacement.loc.start.column
    };
    shiftNode(replacement, shift);
    // Apply offsets after replacement node
    const existing_span = getSpan(existing.loc);
    const replacement_span = getSpan(replacement.loc);
    const offset = {
        lines: replacement_span.lines - existing_span.lines,
        columns: replacement_span.columns - existing_span.columns
    };
    addOffset(offset, getExit(root), replacement, existing);
}
function insert(root, parent, child, index) {
    if (!hasItems(parent)) {
        throw new Error(`Unsupported parent type "${parent.type}" for insert`);
    }
    index = index != null ? index : parent.items.length;
    let shift;
    let offset;
    if (isInlineArray(parent) || isInlineTable(parent)) {
        ({ shift, offset } = insertInline(parent, child, index));
    }
    else {
        ({ shift, offset } = insertOnNewLine(parent, child, index));
    }
    shiftNode(child, shift);
    // The child element is placed relative to the previous element,
    // if the previous element has an offset, need to position relative to that
    // -> Move previous offset to child's offset
    const previous = parent.items[index - 1];
    const previous_offset = previous && getExit(root).get(previous);
    if (previous_offset) {
        offset.lines += previous_offset.lines;
        offset.columns += previous_offset.columns;
        // Account for comma overlay
        //
        // a = [b, e]
        // a = [b, c, e]
        //       ^---^
        // a = [b, c, d, e]
        //          ^---^
        if (isInlineItem(child) && previous && parent.items[index + 1]) {
            offset.columns -= 2;
        }
        getExit(root).delete(previous);
    }
    const offsets = getExit(root);
    offsets.set(child, offset);
}
function insertOnNewLine(parent, child, index) {
    if (!isBlock(child)) {
        throw new Error(`Incompatible child type "${child.type}"`);
    }
    const previous = parent.items[index - 1];
    const use_first_line = isDocument(parent) && !parent.items.length;
    parent.items.splice(index, 0, child);
    // Set start location from previous item or start of array
    // (previous is undefined for empty array or inserting at first item)
    const start = previous
        ? {
            line: previous.loc.end.line,
            column: !isComment(previous) ? previous.loc.start.column : parent.loc.start.column
        }
        : clonePosition(parent.loc.start);
    const is_block = isTable(child) || isTableArray(child);
    let leading_lines = 0;
    if (use_first_line) ;
    else if (is_block) {
        leading_lines = 2;
    }
    else {
        leading_lines = 1;
    }
    start.line += leading_lines;
    const shift = {
        lines: start.line - child.loc.start.line,
        columns: start.column - child.loc.start.column
    };
    // Apply offsets after child node
    const child_span = getSpan(child.loc);
    const offset = {
        lines: child_span.lines + (leading_lines - 1),
        columns: child_span.columns
    };
    return { shift, offset };
}
function insertInline(parent, child, index) {
    if (!isInlineItem(child)) {
        throw new Error(`Incompatible child type "${child.type}"`);
    }
    // Store preceding node and insert
    const previous = index != null ? parent.items[index - 1] : last(parent.items);
    const is_last = index == null || index === parent.items.length;
    parent.items.splice(index, 0, child);
    // Add commas as-needed
    const leading_comma = !!previous;
    const trailing_comma = !is_last;
    const last_comma = is_last && child.comma === true;
    if (leading_comma) {
        previous.comma = true;
    }
    if (trailing_comma) {
        child.comma = true;
    }
    // Use a new line for documents, children of Table/TableArray,
    // and if an inline table is using new lines
    const use_new_line = isInlineArray(parent) && perLine(parent);
    // Set start location from previous item or start of array
    // (previous is undefined for empty array or inserting at first item)
    const start = previous
        ? {
            line: previous.loc.end.line,
            column: use_new_line
                ? !isComment(previous)
                    ? previous.loc.start.column
                    : parent.loc.start.column
                : previous.loc.end.column
        }
        : clonePosition(parent.loc.start);
    let leading_lines = 0;
    if (use_new_line) {
        leading_lines = 1;
    }
    else {
        const skip_comma = 2;
        const skip_bracket = 1;
        start.column += leading_comma ? skip_comma : skip_bracket;
    }
    start.line += leading_lines;
    const shift = {
        lines: start.line - child.loc.start.line,
        columns: start.column - child.loc.start.column
    };
    // Apply offsets after child node
    const child_span = getSpan(child.loc);
    const offset = {
        lines: child_span.lines + (leading_lines - 1),
        columns: child_span.columns + (leading_comma || trailing_comma ? 2 : 0) + (last_comma ? 1 : 0)
    };
    return { shift, offset };
}
function remove(root, parent, node) {
    // Remove an element from the parent's items
    // (supports Document, Table, TableArray, InlineTable, and InlineArray
    //
    //      X
    // [ 1, 2, 3 ]
    //    ^-^
    // -> Remove element 2 and apply 0,-3 offset to 1
    //
    // [table]
    // a = 1
    // b = 2 # X
    // c = 3
    // -> Remove element 2 and apply -1,0 offset to 1
    if (!hasItems(parent)) {
        throw new Error(`Unsupported parent type "${parent.type}" for remove`);
    }
    let index = parent.items.indexOf(node);
    if (index < 0) {
        // Try again, looking at child items for nodes like InlineArrayItem
        index = parent.items.findIndex(item => hasItem(item) && item.item === node);
        if (index < 0) {
            throw new Error('Could not find node in parent for removal');
        }
        node = parent.items[index];
    }
    const previous = parent.items[index - 1];
    let next = parent.items[index + 1];
    // Remove node
    parent.items.splice(index, 1);
    let removed_span = getSpan(node.loc);
    // Remove an associated comment that appears on the same line
    //
    // [table]
    // a = 1
    // b = 2 # remove this too
    // c = 3
    //
    // TODO InlineTable - this only applies to comments in Table/TableArray
    if (next && isComment(next) && next.loc.start.line === node.loc.end.line) {
        // Add comment to removed
        removed_span = getSpan({ start: node.loc.start, end: next.loc.end });
        // Shift to next item
        // (use same index since node has already been removed)
        next = parent.items[index + 1];
        // Remove comment
        parent.items.splice(index, 1);
    }
    // For inline tables and arrays, check whether the line should be kept
    const is_inline = previous && isInlineItem(previous);
    const previous_on_same_line = previous && previous.loc.end.line === node.loc.start.line;
    const next_on_sameLine = next && next.loc.start.line === node.loc.end.line;
    const keep_line = is_inline && (previous_on_same_line || next_on_sameLine);
    const offset = {
        lines: -(removed_span.lines - (keep_line ? 1 : 0)),
        columns: -removed_span.columns
    };
    // Offset for comma and remove comma from previous (if-needed)
    if (is_inline && previous_on_same_line) {
        offset.columns -= 2;
    }
    if (is_inline && previous && !next) {
        previous.comma = false;
    }
    // Apply offsets after preceding node or before children of parent node
    const target = previous || parent;
    const target_offsets = previous ? getExit(root) : getEnter(root);
    const node_offsets = getExit(root);
    const previous_offset = target_offsets.get(target);
    if (previous_offset) {
        offset.lines += previous_offset.lines;
        offset.columns += previous_offset.columns;
    }
    const removed_offset = node_offsets.get(node);
    if (removed_offset) {
        offset.lines += removed_offset.lines;
        offset.columns += removed_offset.columns;
    }
    target_offsets.set(target, offset);
}
function applyBracketSpacing(root, node, bracket_spacing = true) {
    // Can only add bracket spacing currently
    if (!bracket_spacing)
        return;
    if (!node.items.length)
        return;
    // Apply enter to node so that items are affected
    addOffset({ lines: 0, columns: 1 }, getEnter(root), node);
    // Apply exit to last node in items
    const last_item = last(node.items);
    addOffset({ lines: 0, columns: 1 }, getExit(root), last_item);
}
function applyTrailingComma(root, node, trailing_commas = false) {
    // Can only add trailing comma currently
    if (!trailing_commas)
        return;
    if (!node.items.length)
        return;
    const last_item = last(node.items);
    last_item.comma = true;
    addOffset({ lines: 0, columns: 1 }, getExit(root), last_item);
}
function applyWrites(root) {
    const enter = getEnter(root);
    const exit = getExit(root);
    const offset = {
        lines: 0,
        columns: {}
    };
    function shiftStart(node) {
        node.loc.start.line += offset.lines;
        node.loc.start.column += offset.columns[node.loc.start.line] || 0;
        const entering = enter.get(node);
        if (entering) {
            offset.lines += entering.lines;
            offset.columns[node.loc.start.line] =
                (offset.columns[node.loc.start.line] || 0) + entering.columns;
        }
    }
    function shiftEnd(node) {
        node.loc.end.line += offset.lines;
        node.loc.end.column += offset.columns[node.loc.end.line] || 0;
        const exiting = exit.get(node);
        if (exiting) {
            offset.lines += exiting.lines;
            offset.columns[node.loc.end.line] =
                (offset.columns[node.loc.end.line] || 0) + exiting.columns;
        }
    }
    const shiftLocation = {
        enter: shiftStart,
        exit: shiftEnd
    };
    traverse(root, {
        [NodeType.Document]: shiftLocation,
        [NodeType.Table]: shiftLocation,
        [NodeType.TableArray]: shiftLocation,
        [NodeType.InlineTable]: shiftLocation,
        [NodeType.InlineArray]: shiftLocation,
        [NodeType.InlineItem]: shiftLocation,
        [NodeType.TableKey]: shiftLocation,
        [NodeType.TableArrayKey]: shiftLocation,
        [NodeType.KeyValue]: {
            enter(node) {
                const start_line = node.loc.start.line + offset.lines;
                const key_offset = exit.get(node.key);
                node.equals += (offset.columns[start_line] || 0) + (key_offset ? key_offset.columns : 0);
                shiftStart(node);
            },
            exit: shiftEnd
        },
        [NodeType.Key]: shiftLocation,
        [NodeType.String]: shiftLocation,
        [NodeType.Integer]: shiftLocation,
        [NodeType.Float]: shiftLocation,
        [NodeType.Boolean]: shiftLocation,
        [NodeType.DateTime]: shiftLocation,
        [NodeType.Comment]: shiftLocation
    });
    enter_offsets.delete(root);
    exit_offsets.delete(root);
}
function shiftNode(node, span, options = {}) {
    const { first_line_only = false } = options;
    const start_line = node.loc.start.line;
    const { lines, columns } = span;
    const move = (node) => {
        if (!first_line_only || node.loc.start.line === start_line) {
            node.loc.start.column += columns;
            node.loc.end.column += columns;
        }
        node.loc.start.line += lines;
        node.loc.end.line += lines;
    };
    traverse(node, {
        [NodeType.Table]: move,
        [NodeType.TableKey]: move,
        [NodeType.TableArray]: move,
        [NodeType.TableArrayKey]: move,
        [NodeType.KeyValue](node) {
            move(node);
            node.equals += columns;
        },
        [NodeType.Key]: move,
        [NodeType.String]: move,
        [NodeType.Integer]: move,
        [NodeType.Float]: move,
        [NodeType.Boolean]: move,
        [NodeType.DateTime]: move,
        [NodeType.InlineArray]: move,
        [NodeType.InlineItem]: move,
        [NodeType.InlineTable]: move,
        [NodeType.Comment]: move
    });
    return node;
}
function perLine(array) {
    if (!array.items.length)
        return false;
    const span = getSpan(array.loc);
    return span.lines > array.items.length;
}
function addOffset(offset, offsets, node, from) {
    const previous_offset = offsets.get(from || node);
    if (previous_offset) {
        offset.lines += previous_offset.lines;
        offset.columns += previous_offset.columns;
    }
    offsets.set(node, offset);
}

function generateDocument() {
    return {
        type: NodeType.Document,
        loc: { start: zero(), end: zero() },
        items: []
    };
}
function generateTable(key) {
    const table_key = generateTableKey(key);
    return {
        type: NodeType.Table,
        loc: cloneLocation(table_key.loc),
        key: table_key,
        items: []
    };
}
function generateTableKey(key) {
    const raw = keyValueToRaw(key);
    return {
        type: NodeType.TableKey,
        loc: {
            start: zero(),
            end: { line: 1, column: raw.length + 2 }
        },
        item: {
            type: NodeType.Key,
            loc: {
                start: { line: 1, column: 1 },
                end: { line: 1, column: raw.length + 1 }
            },
            value: key,
            raw
        }
    };
}
function generateTableArray(key) {
    const table_array_key = generateTableArrayKey(key);
    return {
        type: NodeType.TableArray,
        loc: cloneLocation(table_array_key.loc),
        key: table_array_key,
        items: []
    };
}
function generateTableArrayKey(key) {
    const raw = keyValueToRaw(key);
    return {
        type: NodeType.TableArrayKey,
        loc: {
            start: zero(),
            end: { line: 1, column: raw.length + 4 }
        },
        item: {
            type: NodeType.Key,
            loc: {
                start: { line: 1, column: 2 },
                end: { line: 1, column: raw.length + 2 }
            },
            value: key,
            raw
        }
    };
}
function generateKeyValue(key, value) {
    const key_node = generateKey(key);
    const { column } = key_node.loc.end;
    const equals = column + 1;
    shiftNode(value, { lines: 0, columns: column + 3 - value.loc.start.column }, { first_line_only: true });
    return {
        type: NodeType.KeyValue,
        loc: {
            start: clonePosition(key_node.loc.start),
            end: clonePosition(value.loc.end)
        },
        key: key_node,
        equals,
        value
    };
}
const IS_BARE_KEY = /[\w,\d,\_,\-]+/;
function keyValueToRaw(value) {
    return value.map(part => (IS_BARE_KEY.test(part) ? part : JSON.stringify(part))).join('.');
}
function generateKey(value) {
    const raw = keyValueToRaw(value);
    return {
        type: NodeType.Key,
        loc: { start: zero(), end: { line: 1, column: raw.length } },
        raw,
        value
    };
}
function generateString(value) {
    const raw = JSON.stringify(value);
    return {
        type: NodeType.String,
        loc: { start: zero(), end: { line: 1, column: raw.length } },
        raw,
        value
    };
}
function generateInteger(value) {
    const raw = value.toString();
    return {
        type: NodeType.Integer,
        loc: { start: zero(), end: { line: 1, column: raw.length } },
        raw,
        value
    };
}
function generateFloat(value) {
    const raw = value.toString();
    return {
        type: NodeType.Float,
        loc: { start: zero(), end: { line: 1, column: raw.length } },
        raw,
        value
    };
}
function generateBoolean(value) {
    return {
        type: NodeType.Boolean,
        loc: { start: zero(), end: { line: 1, column: value ? 4 : 5 } },
        value
    };
}
function generateDateTime(value) {
    const raw = value.toISOString();
    return {
        type: NodeType.DateTime,
        loc: { start: zero(), end: { line: 1, column: raw.length } },
        raw,
        value
    };
}
function generateInlineArray() {
    return {
        type: NodeType.InlineArray,
        loc: { start: zero(), end: { line: 1, column: 2 } },
        items: []
    };
}
function generateInlineItem(item) {
    return {
        type: NodeType.InlineItem,
        loc: cloneLocation(item.loc),
        item,
        comma: false
    };
}
function generateInlineTable() {
    return {
        type: NodeType.InlineTable,
        loc: { start: zero(), end: { line: 1, column: 2 } },
        items: []
    };
}

function formatTopLevel(document) {
    const move_to_top_level = document.items.filter(item => {
        if (!isKeyValue(item))
            return false;
        const is_inline_table = isInlineTable(item.value);
        const is_inline_array = isInlineArray(item.value) &&
            item.value.items.length &&
            isInlineTable(item.value.items[0].item);
        return is_inline_table || is_inline_array;
    });
    move_to_top_level.forEach(node => {
        remove(document, document, node);
        if (isInlineTable(node.value)) {
            insert(document, document, formatTable(node));
        }
        else {
            formatTableArray(node).forEach(table_array => {
                insert(document, document, table_array);
            });
        }
    });
    applyWrites(document);
    return document;
}
function formatTable(key_value) {
    const table = generateTable(key_value.key.value);
    for (const item of key_value.value.items) {
        insert(table, table, item.item);
    }
    applyWrites(table);
    return table;
}
function formatTableArray(key_value) {
    const root = generateDocument();
    for (const inline_array_item of key_value.value.items) {
        const table_array = generateTableArray(key_value.key.value);
        insert(root, root, table_array);
        for (const inline_table_item of inline_array_item.item.items) {
            insert(root, table_array, inline_table_item.item);
        }
    }
    applyWrites(root);
    return root.items;
}
function formatPrintWidth(document, format) {
    // TODO
    return document;
}
function formatEmptyLines(document) {
    let shift = 0;
    let previous = 0;
    for (const item of document.items) {
        if (previous === 0 && item.loc.start.line > 1) {
            // Remove leading newlines
            shift = 1 - item.loc.start.line;
        }
        else if (item.loc.start.line + shift > previous + 2) {
            shift += previous + 2 - (item.loc.start.line + shift);
        }
        shiftNode(item, {
            lines: shift,
            columns: 0
        });
        previous = item.loc.end.line;
    }
    return document;
}

const default_format = {
    printWidth: 80,
    trailingComma: false,
    bracketSpacing: true
};
function parseJS(value, format = {}) {
    format = Object.assign({}, default_format, format);
    value = toJSON(value);
    const document = generateDocument();
    for (const item of walkObject(value, format)) {
        insert(document, document, item);
    }
    applyWrites(document);
    // Heuristics:
    // 1. Top-level objects/arrays should be tables/table arrays
    // 2. Convert objects/arrays to tables/table arrays based on print width
    const formatted = pipe(document, formatTopLevel, document => formatPrintWidth(document), formatEmptyLines);
    return formatted;
}
function* walkObject(object, format) {
    for (const key of Object.keys(object)) {
        yield generateKeyValue([key], walkValue$1(object[key], format));
    }
}
function walkValue$1(value, format) {
    if (value == null) {
        throw new Error('"null" and "undefined" values are not supported');
    }
    if (isString(value)) {
        return generateString(value);
    }
    else if (isInteger(value)) {
        return generateInteger(value);
    }
    else if (isFloat(value)) {
        return generateFloat(value);
    }
    else if (isBoolean(value)) {
        return generateBoolean(value);
    }
    else if (isDate(value)) {
        return generateDateTime(value);
    }
    else if (Array.isArray(value)) {
        return walkInlineArray(value, format);
    }
    else {
        return walkInlineTable(value, format);
    }
}
function walkInlineArray(value, format) {
    const inline_array = generateInlineArray();
    for (const element of value) {
        const item = walkValue$1(element, format);
        const inline_array_item = generateInlineItem(item);
        insert(inline_array, inline_array, inline_array_item);
    }
    applyBracketSpacing(inline_array, inline_array, format.bracketSpacing);
    applyTrailingComma(inline_array, inline_array, format.trailingComma);
    applyWrites(inline_array);
    return inline_array;
}
function walkInlineTable(value, format) {
    value = toJSON(value);
    if (!isObject(value))
        return walkValue$1(value, format);
    const inline_table = generateInlineTable();
    const items = [...walkObject(value, format)];
    for (const item of items) {
        const inline_table_item = generateInlineItem(item);
        insert(inline_table, inline_table, inline_table_item);
    }
    applyBracketSpacing(inline_table, inline_table, format.bracketSpacing);
    applyTrailingComma(inline_table, inline_table, format.trailingComma);
    applyWrites(inline_table);
    return inline_table;
}
function toJSON(value) {
    return value && !isDate(value) && typeof value.toJSON === 'function' ? value.toJSON() : value;
}

const BY_NEW_LINE = /(\r\n|\n)/g;
function toTOML(ast, newline = '\n') {
    const lines = [];
    traverse(ast, {
        [NodeType.TableKey](node) {
            const { start, end } = node.loc;
            write(lines, { start, end: { line: start.line, column: start.column + 1 } }, '[');
            write(lines, { start: { line: end.line, column: end.column - 1 }, end }, ']');
        },
        [NodeType.TableArrayKey](node) {
            const { start, end } = node.loc;
            write(lines, { start, end: { line: start.line, column: start.column + 2 } }, '[[');
            write(lines, { start: { line: end.line, column: end.column - 2 }, end }, ']]');
        },
        [NodeType.KeyValue](node) {
            const { start: { line } } = node.loc;
            write(lines, { start: { line, column: node.equals }, end: { line, column: node.equals + 1 } }, '=');
        },
        [NodeType.Key](node) {
            write(lines, node.loc, node.raw);
        },
        [NodeType.String](node) {
            write(lines, node.loc, node.raw);
        },
        [NodeType.Integer](node) {
            write(lines, node.loc, node.raw);
        },
        [NodeType.Float](node) {
            write(lines, node.loc, node.raw);
        },
        [NodeType.Boolean](node) {
            write(lines, node.loc, node.value.toString());
        },
        [NodeType.DateTime](node) {
            write(lines, node.loc, node.raw);
        },
        [NodeType.InlineArray](node) {
            const { start, end } = node.loc;
            write(lines, { start, end: { line: start.line, column: start.column + 1 } }, '[');
            write(lines, { start: { line: end.line, column: end.column - 1 }, end }, ']');
        },
        [NodeType.InlineTable](node) {
            const { start, end } = node.loc;
            write(lines, { start, end: { line: start.line, column: start.column + 1 } }, '{');
            write(lines, { start: { line: end.line, column: end.column - 1 }, end }, '}');
        },
        [NodeType.InlineItem](node) {
            if (!node.comma)
                return;
            const start = node.loc.end;
            write(lines, { start, end: { line: start.line, column: start.column + 1 } }, ',');
        },
        [NodeType.Comment](node) {
            write(lines, node.loc, node.raw);
        }
    });
    return lines.join(newline) + newline;
}
function write(lines, loc, raw) {
    const raw_lines = raw.split(BY_NEW_LINE);
    const expected_lines = loc.end.line - loc.start.line + 1;
    if (raw_lines.length !== expected_lines) {
        throw new Error(`Mismatch between location and raw string, expected ${expected_lines} lines for "${raw}"`);
    }
    for (let i = loc.start.line; i <= loc.end.line; i++) {
        const line = getLine$1(lines, i);
        const is_start_line = i === loc.start.line;
        const is_end_line = i === loc.end.line;
        const before = is_start_line
            ? line.substr(0, loc.start.column).padEnd(loc.start.column, SPACE)
            : '';
        const after = is_end_line ? line.substr(loc.end.column) : '';
        lines[i - 1] = before + raw_lines[i - loc.start.line] + after;
    }
}
function getLine$1(lines, index) {
    if (!lines[index - 1]) {
        for (let i = 0; i < index; i++) {
            if (!lines[i])
                lines[i] = '';
        }
    }
    return lines[index - 1];
}

function toJS(ast, input = '') {
    const result = blank();
    const tables = new Set();
    const table_arrays = new Set();
    const defined = new Set();
    let active = result;
    let previous_active;
    let skip = false;
    traverse(ast, {
        [NodeType.Table](node) {
            const key = node.key.item.value;
            try {
                validateKey(result, key, node.type, { tables, table_arrays, defined });
            }
            catch (err) {
                throw new ParseError(input, node.key.loc.start, err.message);
            }
            const joined_key = joinKey(key);
            tables.add(joined_key);
            defined.add(joined_key);
            active = ensureTable(result, key);
        },
        [NodeType.TableArray](node) {
            const key = node.key.item.value;
            try {
                validateKey(result, key, node.type, { tables, table_arrays, defined });
            }
            catch (err) {
                throw new ParseError(input, node.key.loc.start, err.message);
            }
            const joined_key = joinKey(key);
            table_arrays.add(joined_key);
            defined.add(joined_key);
            active = ensureTableArray(result, key);
        },
        [NodeType.KeyValue]: {
            enter(node) {
                if (skip)
                    return;
                const key = node.key.value;
                try {
                    validateKey(active, key, node.type, { tables, table_arrays, defined });
                }
                catch (err) {
                    throw new ParseError(input, node.key.loc.start, err.message);
                }
                const value = toValue(node.value);
                const target = key.length > 1 ? ensureTable(active, key.slice(0, -1)) : active;
                target[last(key)] = value;
                defined.add(joinKey(key));
                if (isInlineTable(node.value)) {
                    previous_active = active;
                    active = value;
                }
            },
            exit(node) {
                if (isInlineTable(node.value)) {
                    active = previous_active;
                }
            }
        },
        [NodeType.InlineTable]: {
            enter() {
                // Handled by toValue
                skip = true;
            },
            exit() {
                skip = false;
            }
        }
    });
    return result;
}
function toValue(node) {
    switch (node.type) {
        case NodeType.InlineTable:
            const result = blank();
            node.items.forEach(({ item }) => {
                const key = item.key.value;
                const value = toValue(item.value);
                const target = key.length > 1 ? ensureTable(result, key.slice(0, -1)) : result;
                target[last(key)] = value;
            });
            return result;
        case NodeType.InlineArray:
            return node.items.map(item => toValue(item.item));
        case NodeType.String:
        case NodeType.Integer:
        case NodeType.Float:
        case NodeType.Boolean:
        case NodeType.DateTime:
            return node.value;
        default:
            throw new Error(`Unrecognized value type "${node.type}"`);
    }
}
function validateKey(object, key, type, state) {
    // 1. Cannot override primitive value
    let parts = [];
    let index = 0;
    for (const part of key) {
        parts.push(part);
        if (!has(object, part))
            return;
        if (isPrimitive(object[part])) {
            throw new Error(`Invalid key, a value has already been defined for ${parts.join('.')}`);
        }
        const joined_parts = joinKey(parts);
        if (Array.isArray(object[part]) && !state.table_arrays.has(joined_parts)) {
            throw new Error(`Invalid key, cannot add to a static array at ${joined_parts}`);
        }
        const next_is_last = index++ < key.length - 1;
        object = Array.isArray(object[part]) && next_is_last ? last(object[part]) : object[part];
    }
    const joined_key = joinKey(key);
    // 2. Cannot override table
    if (object && type === NodeType.Table && state.defined.has(joined_key)) {
        throw new Error(`Invalid key, a table has already been defined named ${joined_key}`);
    }
    // 3. Cannot add table array to static array or table
    if (object && type === NodeType.TableArray && !state.table_arrays.has(joined_key)) {
        throw new Error(`Invalid key, cannot add an array of tables to a table at ${joined_key}`);
    }
}
function ensureTable(object, key) {
    const target = ensure(object, key.slice(0, -1));
    const last_key = last(key);
    if (!target[last_key]) {
        target[last_key] = blank();
    }
    return target[last_key];
}
function ensureTableArray(object, key) {
    const target = ensure(object, key.slice(0, -1));
    const last_key = last(key);
    if (!target[last_key]) {
        target[last_key] = [];
    }
    const next = blank();
    target[last(key)].push(next);
    return next;
}
function ensure(object, keys) {
    return keys.reduce((active, subkey) => {
        if (!active[subkey]) {
            active[subkey] = blank();
        }
        return Array.isArray(active[subkey]) ? last(active[subkey]) : active[subkey];
    }, object);
}
function isPrimitive(value) {
    return typeof value !== 'object' && !isDate(value);
}
function joinKey(key) {
    return key.join('.');
}

var ChangeType;
(function (ChangeType) {
    ChangeType["Add"] = "Add";
    ChangeType["Edit"] = "Edit";
    ChangeType["Remove"] = "Remove";
    ChangeType["Move"] = "Move";
    ChangeType["Rename"] = "Rename";
})(ChangeType || (ChangeType = {}));
function isAdd(change) {
    return change.type === ChangeType.Add;
}
function isEdit(change) {
    return change.type === ChangeType.Edit;
}
function isRemove(change) {
    return change.type === ChangeType.Remove;
}
function isMove(change) {
    return change.type === ChangeType.Move;
}
function isRename(change) {
    return change.type === ChangeType.Rename;
}
function diff(before, after, path = []) {
    if (before === after || datesEqual(before, after)) {
        return [];
    }
    if (Array.isArray(before) && Array.isArray(after)) {
        return compareArrays(before, after, path);
    }
    else if (isObject(before) && isObject(after)) {
        return compareObjects(before, after, path);
    }
    else {
        return [
            {
                type: ChangeType.Edit,
                path
            }
        ];
    }
}
function compareObjects(before, after, path = []) {
    let changes = [];
    // 1. Get keys and stable values
    const before_keys = Object.keys(before);
    const before_stable = before_keys.map(key => stableStringify(before[key]));
    const after_keys = Object.keys(after);
    const after_stable = after_keys.map(key => stableStringify(after[key]));
    // Check for rename by seeing if object is in both before and after
    // and that key is no longer used in after
    const isRename = (stable, search) => {
        const index = search.indexOf(stable);
        if (index < 0)
            return false;
        const before_key = before_keys[before_stable.indexOf(stable)];
        return !after_keys.includes(before_key);
    };
    // 2. Check for changes, rename, and removed
    before_keys.forEach((key, index) => {
        const sub_path = path.concat(key);
        if (after_keys.includes(key)) {
            merge(changes, diff(before[key], after[key], sub_path));
        }
        else if (isRename(before_stable[index], after_stable)) {
            const to = after_keys[after_stable.indexOf(before_stable[index])];
            changes.push({
                type: ChangeType.Rename,
                path,
                from: key,
                to
            });
        }
        else {
            changes.push({
                type: ChangeType.Remove,
                path: sub_path
            });
        }
    });
    // 3. Check for additions
    after_keys.forEach((key, index) => {
        if (!before_keys.includes(key) && !isRename(after_stable[index], before_stable)) {
            changes.push({
                type: ChangeType.Add,
                path: path.concat(key)
            });
        }
    });
    return changes;
}
function compareArrays(before, after, path = []) {
    let changes = [];
    // 1. Convert arrays to stable objects
    const before_stable = before.map(stableStringify);
    const after_stable = after.map(stableStringify);
    // 2. Step through after array making changes to before array as-needed
    after_stable.forEach((value, index) => {
        const overflow = index >= before_stable.length;
        // Check if items are the same
        if (!overflow && before_stable[index] === value) {
            return;
        }
        // Check if item has been moved -> shift into place
        const from = before_stable.indexOf(value, index + 1);
        if (!overflow && from > -1) {
            changes.push({
                type: ChangeType.Move,
                path,
                from,
                to: index
            });
            const move = before_stable.splice(from, 1);
            before_stable.splice(index, 0, ...move);
            return;
        }
        // Check if item is removed -> assume it's been edited and replace
        const removed = !after_stable.includes(before_stable[index]);
        if (!overflow && removed) {
            merge(changes, diff(before[index], after[index], path.concat(index)));
            before_stable[index] = value;
            return;
        }
        // Add as new item and shift existing
        changes.push({
            type: ChangeType.Add,
            path: path.concat(index)
        });
        before_stable.splice(index, 0, value);
    });
    // 3. Remove any remaining overflow items
    for (let i = after_stable.length; i < before_stable.length; i++) {
        changes.push({
            type: ChangeType.Remove,
            path: path.concat(i)
        });
    }
    return changes;
}

function findByPath(node, path) {
    if (!path.length)
        return node;
    if (isKeyValue(node)) {
        return findByPath(node.value, path);
    }
    const indexes = {};
    let found;
    if (hasItems(node)) {
        node.items.some((item, index) => {
            try {
                let key = [];
                if (isKeyValue(item)) {
                    key = item.key.value;
                }
                else if (isTable(item)) {
                    key = item.key.item.value;
                }
                else if (isTableArray(item)) {
                    key = item.key.item.value;
                    const key_string = stableStringify(key);
                    if (!indexes[key_string]) {
                        indexes[key_string] = 0;
                    }
                    const array_index = indexes[key_string]++;
                    key = key.concat(array_index);
                }
                else if (isInlineItem(item) && isKeyValue(item.item)) {
                    key = item.item.key.value;
                }
                else if (isInlineItem(item)) {
                    key = [index];
                }
                if (key.length && arraysEqual(key, path.slice(0, key.length))) {
                    found = findByPath(item, path.slice(key.length));
                    return true;
                }
                else {
                    return false;
                }
            }
            catch (err) {
                return false;
            }
        });
    }
    if (!found) {
        throw new Error(`Could not find node at path ${path.join('.')}`);
    }
    return found;
}
function tryFindByPath(node, path) {
    try {
        return findByPath(node, path);
    }
    catch (err) { }
}
function findParent(node, path) {
    let parent_path = path;
    let parent;
    while (parent_path.length && !parent) {
        parent_path = parent_path.slice(0, -1);
        parent = tryFindByPath(node, parent_path);
    }
    if (!parent) {
        throw new Error(`Count not find parent node for path ${path.join('.')}`);
    }
    return parent;
}

function patch(existing, updated, format) {
    const existing_ast = parseTOML(existing);
    const items = [...existing_ast];
    const existing_js = toJS(items);
    const existing_document = {
        type: NodeType.Document,
        loc: { start: { line: 1, column: 0 }, end: { line: 1, column: 0 } },
        items
    };
    const updated_document = parseJS(updated, format);
    const changes = diff(existing_js, updated);
    const patched_document = applyChanges(existing_document, updated_document, changes);
    return toTOML(patched_document.items);
}
function applyChanges(original, updated, changes) {
    // Potential Changes:
    //
    // Add: Add key-value to object, add item to array
    // Edit: Change in value
    // Remove: Remove key-value from object, remove item from array
    // Move: Move item in array
    // Rename: Rename key in key-value
    //
    // Special consideration, inline comments need to move as-needed
    changes.forEach(change => {
        if (isAdd(change)) {
            const child = findByPath(updated, change.path);
            const parent_path = change.path.slice(0, -1);
            let index = last(change.path);
            let is_table_array = isTableArray(child);
            if (isInteger(index) && !parent_path.some(isInteger)) {
                const sibling = tryFindByPath(original, parent_path.concat(0));
                if (sibling && isTableArray(sibling)) {
                    is_table_array = true;
                }
            }
            let parent;
            if (isTable(child)) {
                parent = original;
            }
            else if (is_table_array) {
                parent = original;
                // The index needs to be updated to top-level items
                // to properly account for other items, comments, and nesting
                const document = original;
                const before = tryFindByPath(document, parent_path.concat(index - 1));
                const after = tryFindByPath(document, parent_path.concat(index));
                if (after) {
                    index = document.items.indexOf(after);
                }
                else if (before) {
                    index = document.items.indexOf(before) + 1;
                }
                else {
                    index = document.items.length;
                }
            }
            else {
                parent = findParent(original, change.path);
                if (isKeyValue(parent))
                    parent = parent.value;
            }
            if (isTableArray(parent) || isInlineArray(parent) || isDocument(parent)) {
                insert(original, parent, child, index);
            }
            else {
                insert(original, parent, child);
            }
        }
        else if (isEdit(change)) {
            let existing = findByPath(original, change.path);
            let replacement = findByPath(updated, change.path);
            let parent;
            if (isKeyValue(existing) && isKeyValue(replacement)) {
                // Edit for key-value means value changes
                parent = existing;
                existing = existing.value;
                replacement = replacement.value;
            }
            else {
                parent = findParent(original, change.path);
            }
            replace(original, parent, existing, replacement);
        }
        else if (isRemove(change)) {
            let parent = findParent(original, change.path);
            if (isKeyValue(parent))
                parent = parent.value;
            const node = findByPath(original, change.path);
            remove(original, parent, node);
        }
        else if (isMove(change)) {
            let parent = findByPath(original, change.path);
            if (hasItem(parent))
                parent = parent.item;
            if (isKeyValue(parent))
                parent = parent.value;
            const node = parent.items[change.from];
            remove(original, parent, node);
            insert(original, parent, node, change.to);
        }
        else if (isRename(change)) {
            let parent = findByPath(original, change.path.concat(change.from));
            let replacement = findByPath(updated, change.path.concat(change.to));
            if (hasItem(parent))
                parent = parent.item;
            if (hasItem(replacement))
                replacement = replacement.item;
            replace(original, parent, parent.key, replacement.key);
        }
    });
    applyWrites(original);
    return original;
}

function parse(value) {
    return toJS(parseTOML(value), value);
}
function stringify(value, format) {
    const document = parseJS(value, format);
    return toTOML(document.items);
}

export { parse, patch, stringify };
