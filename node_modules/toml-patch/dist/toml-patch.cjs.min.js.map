{"version":3,"file":"toml-patch.cjs.min.js","sources":["../src/ast.ts","../src/tokenizer.ts","../src/cursor.ts","../src/location.ts","../src/parse-error.ts","../src/utils.ts","../src/parse-string.ts","../src/parse-toml.ts","../src/traverse.ts","../src/writer.ts","../src/generate.ts","../src/format.ts","../src/parse-js.ts","../src/to-toml.ts","../src/to-js.ts","../src/diff.ts","../src/find-by-path.ts","../src/patch.ts","../src/index.ts"],"sourcesContent":["import { Location } from './location';\n\nexport enum NodeType {\n  Document = 'Document',\n  Table = 'Table',\n  TableKey = 'TableKey',\n  TableArray = 'TableArray',\n  TableArrayKey = 'TableArrayKey',\n  KeyValue = 'KeyValue',\n  Key = 'Key',\n  String = 'String',\n  Integer = 'Integer',\n  Float = 'Float',\n  Boolean = 'Boolean',\n  DateTime = 'DateTime',\n  InlineArray = 'InlineArray',\n  InlineItem = 'InlineItem',\n  InlineTable = 'InlineTable',\n  Comment = 'Comment'\n}\n\nexport type AST = Iterable<Block>;\n\n//\n// Document\n//\n// Top-level document that stores AST nodes\n//\nexport interface Document extends Node {\n  type: NodeType.Document;\n  items: Array<Block>;\n}\nexport function isDocument(node: Node): node is Document {\n  return node.type === NodeType.Document;\n}\n\n//\n// Table\n//\n// Top-level object\n//\n// v-------|\n// [table] |\n// b = \"c\" |\n//         |\n// # note  |\n//      ^--|\n// [b]\n//\nexport interface Table extends Node {\n  type: NodeType.Table;\n  key: TableKey;\n  items: Array<KeyValue | Comment>;\n}\nexport function isTable(node: Node): node is Table {\n  return node.type === NodeType.Table;\n}\n\n//\n// TableKey\n//\n// Used to store bracket information for Table keys\n//\n// loc includes brackets\n//\n// [  key  ]\n// ^-------^\n//\nexport interface TableKey extends Node {\n  type: NodeType.TableKey;\n  item: Key;\n}\nexport function isTableKey(node: Node): node is TableKey {\n  return node.type === NodeType.TableKey;\n}\n\n//\n// TableArray\n//\n// Top-level array item\n//\n// v---------|\n// [[array]] |\n// a=\"b\"     |\n//           |\n// # details |\n//         ^-|\n// [[array]]\n//\nexport interface TableArray extends Node {\n  type: NodeType.TableArray;\n  key: TableArrayKey;\n  items: Array<KeyValue | Comment>;\n}\nexport function isTableArray(node: Node): node is TableArray {\n  return node.type === NodeType.TableArray;\n}\n\n//\n// TableArrayKey\n//\n// Used to store bracket information for TableArray keys\n// loc includes brackets\n//\n// [[  key  ]]\n// ^---------^\n//\nexport interface TableArrayKey extends Node {\n  type: NodeType.TableArrayKey;\n  item: Key;\n}\nexport function isTableArrayKey(node: Node): node is TableArrayKey {\n  return node.type === NodeType.TableArrayKey;\n}\n\n//\n// KeyValue\n//\n// Key and Value nodes, with position information on equals sign\n//\n// key=\"value\" # note\n// ^---------^\n//\nexport interface KeyValue extends Node {\n  type: NodeType.KeyValue;\n  key: Key;\n  value: Value;\n\n  // Column index (0-based) of equals sign\n  equals: number;\n}\nexport function isKeyValue(node: Node): node is KeyValue {\n  return node.type === NodeType.KeyValue;\n}\n\n//\n// Key\n//\n// Store raw key and parts (from dots)\n//\nexport interface Key extends Node {\n  type: NodeType.Key;\n  raw: string;\n\n  // Note: Array for keys with dots\n  // e.g. a.b -> raw = 'a.b', value = ['a', 'b']\n  value: string[];\n}\nexport function isKey(node: Node): node is Key {\n  return node.type === NodeType.Key;\n}\n\n//\n// String\n//\n// loc includes quotes\n//\n// a = \"string\"\n//     ^------^\n//\nexport interface String extends Node {\n  type: NodeType.String;\n  raw: string;\n  value: string;\n}\nexport function isString(node: Node): node is String {\n  return node.type === NodeType.String;\n}\n\n//\n// Integer\n//\nexport interface Integer extends Node {\n  type: NodeType.Integer;\n  raw: string;\n  value: number;\n}\nexport function isInteger(node: Node): node is Integer {\n  return node.type === NodeType.Integer;\n}\n\n//\n// Float\n//\nexport interface Float extends Node {\n  type: NodeType.Float;\n  raw: string;\n  value: number;\n}\nexport function isFloat(node: Node): node is Float {\n  return node.type === NodeType.Float;\n}\n\n//\n// Boolean\n//\nexport interface Boolean extends Node {\n  type: NodeType.Boolean;\n\n  // Only `true` and `false` are permitted\n  // -> don't need separate raw and value\n  value: boolean;\n}\nexport function isBoolean(node: Node): node is Boolean {\n  return node.type === NodeType.Boolean;\n}\n\n//\n// DateTime\n//\n// Note: Currently, Offset Date-Time, Local Date-Time, Local Date, and Local Time\n// are handled via raw\n//\nexport interface DateTime extends Node {\n  type: NodeType.DateTime;\n  raw: string;\n  value: Date;\n}\nexport function isDateTime(node: Node): node is DateTime {\n  return node.type === NodeType.DateTime;\n}\n\n//\n// InlineArray\n//\nexport interface InlineArray<TItem = Node> extends Node {\n  type: NodeType.InlineArray;\n  items: InlineArrayItem<TItem>[];\n}\nexport function isInlineArray(node: Node): node is InlineArray {\n  return node.type === NodeType.InlineArray;\n}\n\n//\n// InlineArrayItem\n//\n// loc for InlineArrayItem is from start of value to before comma\n// or end-of-value if no comma\n//\n// [ \"a\"  ,\"b\", \"c\"  ]\n//   ^---^ ^-^  ^-^\n//\nexport interface InlineItem<TItem = Node> extends Node {\n  type: NodeType.InlineItem;\n  item: TItem;\n  comma: boolean;\n}\nexport function isInlineItem(node: Node): node is InlineItem {\n  return node.type === NodeType.InlineItem;\n}\n\nexport interface InlineArrayItem<TItem = Node> extends InlineItem<TItem> {}\n\n//\n// InlineTable\n//\nexport interface InlineTable extends Node {\n  type: NodeType.InlineTable;\n  items: InlineTableItem[];\n}\nexport function isInlineTable(node: Node): node is InlineTable {\n  return node.type === NodeType.InlineTable;\n}\n\n//\n// InlineTableItem\n//\n// loc for InlineTableItem follows InlineArrayItem\n//\n// { a=\"b\"   ,    c =    \"d\"   }\n//   ^------^     ^--------^\n//\nexport interface InlineTableItem extends InlineItem<KeyValue> {}\n\n//\n// Comment\n//\n// loc starts at \"#\" and goes to end of comment (trailing whitespace ignored)\n//\n// # comment here\n// ^------------^\n//\nexport interface Comment extends Node {\n  type: NodeType.Comment;\n  raw: string;\n}\nexport function isComment(node: Node): node is Comment {\n  return node.type === NodeType.Comment;\n}\n\n//\n// Combinations\n//\n\nexport interface WithItems extends Node {\n  items: Node[];\n}\nexport function hasItems(node: Node): node is WithItems {\n  return (\n    isDocument(node) ||\n    isTable(node) ||\n    isTableArray(node) ||\n    isInlineTable(node) ||\n    isInlineArray(node)\n  );\n}\n\nexport interface WithItem extends Node {\n  item: Node;\n}\nexport function hasItem(node: Node): node is WithItem {\n  return isTableKey(node) || isTableArrayKey(node) || isInlineItem(node);\n}\n\nexport type Block = KeyValue | Table | TableArray | Comment;\nexport function isBlock(node: Node): node is Block {\n  return isKeyValue(node) || isTable(node) || isTableArray(node) || isComment(node);\n}\n\nexport type Value<TInlineArrayItem = Node> =\n  | String\n  | Integer\n  | Float\n  | Boolean\n  | DateTime\n  | InlineArray<TInlineArrayItem>\n  | InlineTable;\nexport function isValue(node: Node): node is Value {\n  return (\n    isString(node) ||\n    isInteger(node) ||\n    isFloat(node) ||\n    isBoolean(node) ||\n    isDateTime(node) ||\n    isInlineArray(node) ||\n    isInlineTable(node)\n  );\n}\n\nexport interface Node {\n  type: NodeType;\n  loc: Location;\n}\n","import Cursor, { iterator } from './cursor';\nimport { Location, Locator, createLocate, findPosition } from './location';\nimport ParseError from './parse-error';\n\nexport enum TokenType {\n  Bracket = 'Bracket',\n  Curly = 'Curly',\n  Equal = 'Equal',\n  Comma = 'Comma',\n  Dot = 'Dot',\n  Comment = 'Comment',\n  Literal = 'Literal'\n}\n\nexport interface Token {\n  type: TokenType;\n  raw: string;\n  loc: Location;\n}\n\nexport const IS_WHITESPACE = /\\s/;\nexport const IS_NEW_LINE = /(\\r\\n|\\n)/;\nexport const DOUBLE_QUOTE = `\"`;\nexport const SINGLE_QUOTE = `'`;\nexport const SPACE = ' ';\nexport const ESCAPE = '\\\\';\n\nconst IS_VALID_LEADING_CHARACTER = /[\\w,\\d,\\\",\\',\\+,\\-,\\_]/;\n\nexport function* tokenize(input: string): IterableIterator<Token> {\n  const cursor = new Cursor(iterator(input));\n  cursor.next();\n\n  const locate = createLocate(input);\n\n  while (!cursor.done) {\n    if (IS_WHITESPACE.test(cursor.value!)) {\n      // (skip whitespace)\n    } else if (cursor.value === '[' || cursor.value === ']') {\n      // Handle special characters: [, ], {, }, =, comma\n      yield specialCharacter(cursor, locate, TokenType.Bracket);\n    } else if (cursor.value === '{' || cursor.value === '}') {\n      yield specialCharacter(cursor, locate, TokenType.Curly);\n    } else if (cursor.value === '=') {\n      yield specialCharacter(cursor, locate, TokenType.Equal);\n    } else if (cursor.value === ',') {\n      yield specialCharacter(cursor, locate, TokenType.Comma);\n    } else if (cursor.value === '.') {\n      yield specialCharacter(cursor, locate, TokenType.Dot);\n    } else if (cursor.value === '#') {\n      // Handle comments = # -> EOL\n      yield comment(cursor, locate);\n    } else {\n      const multiline_char =\n        checkThree(input, cursor.index, SINGLE_QUOTE) ||\n        checkThree(input, cursor.index, DOUBLE_QUOTE);\n\n      if (multiline_char) {\n        // Multi-line literals or strings = no escaping\n        yield multiline(cursor, locate, multiline_char, input);\n      } else {\n        yield string(cursor, locate, input);\n      }\n    }\n\n    cursor.next();\n  }\n}\n\nfunction specialCharacter(cursor: Cursor<string>, locate: Locator, type: TokenType): Token {\n  return { type, raw: cursor.value!, loc: locate(cursor.index, cursor.index + 1) };\n}\n\nfunction comment(cursor: Cursor<string>, locate: Locator): Token {\n  const start = cursor.index;\n  let raw = cursor.value!;\n  while (!cursor.peek().done && !IS_NEW_LINE.test(cursor.peek().value!)) {\n    cursor.next();\n    raw += cursor.value!;\n  }\n\n  // Early exit is ok for comment, no closing conditions\n\n  return {\n    type: TokenType.Comment,\n    raw,\n    loc: locate(start, cursor.index + 1)\n  };\n}\n\nfunction multiline(\n  cursor: Cursor<string>,\n  locate: Locator,\n  multiline_char: string,\n  input: string\n): Token {\n  const start = cursor.index;\n  let quotes = multiline_char + multiline_char + multiline_char;\n  let raw = quotes;\n\n  // Skip over quotes\n  cursor.next();\n  cursor.next();\n  cursor.next();\n\n  while (!cursor.done && !checkThree(input, cursor.index, multiline_char)) {\n    raw += cursor.value;\n    cursor.next();\n  }\n\n  if (cursor.done) {\n    throw new ParseError(\n      input,\n      findPosition(input, cursor.index),\n      `Expected close of multiline string with ${quotes}, reached end of file`\n    );\n  }\n\n  raw += quotes;\n\n  cursor.next();\n  cursor.next();\n\n  return {\n    type: TokenType.Literal,\n    raw,\n    loc: locate(start, cursor.index + 1)\n  };\n}\n\nfunction string(cursor: Cursor<string>, locate: Locator, input: string): Token {\n  // Remaining possibilities: keys, strings, literals, integer, float, boolean\n  //\n  // Special cases:\n  // \"...\" -> quoted\n  // '...' -> quoted\n  // \"...\".'...' -> bare\n  // 0000-00-00 00:00:00 -> bare\n  //\n  // See https://github.com/toml-lang/toml#offset-date-time\n  //\n  // | For the sake of readability, you may replace the T delimiter between date and time with a space (as permitted by RFC 3339 section 5.6).\n  // | `odt4 = 1979-05-27 07:32:00Z`\n  //\n  // From RFC 3339:\n  //\n  // | NOTE: ISO 8601 defines date and time separated by \"T\".\n  // | Applications using this syntax may choose, for the sake of\n  // | readability, to specify a full-date and full-time separated by\n  // | (say) a space character.\n\n  // First, check for invalid characters\n  if (!IS_VALID_LEADING_CHARACTER.test(cursor.value!)) {\n    throw new ParseError(\n      input,\n      findPosition(input, cursor.index),\n      `Unsupported character \"${cursor.value}\". Expected ALPHANUMERIC, \", ', +, -, or _`\n    );\n  }\n\n  const start = cursor.index;\n  let raw = cursor.value!;\n  let double_quoted = cursor.value === DOUBLE_QUOTE;\n  let single_quoted = cursor.value === SINGLE_QUOTE;\n\n  const isFinished = (cursor: Cursor<string>) => {\n    if (cursor.peek().done) return true;\n    const next_item = cursor.peek().value!;\n\n    return (\n      !(double_quoted || single_quoted) &&\n      (IS_WHITESPACE.test(next_item) ||\n        next_item === ',' ||\n        next_item === '.' ||\n        next_item === ']' ||\n        next_item === '}' ||\n        next_item === '=')\n    );\n  };\n\n  while (!cursor.done && !isFinished(cursor)) {\n    cursor.next();\n\n    if (cursor.value === DOUBLE_QUOTE) double_quoted = !double_quoted;\n    if (cursor.value === SINGLE_QUOTE && !double_quoted) single_quoted = !single_quoted;\n\n    raw += cursor.value!;\n\n    if (cursor.peek().done) break;\n    let next_item = cursor.peek().value!;\n\n    // If next character is escape and currently double-quoted,\n    // check for escaped quote\n    if (double_quoted && cursor.value === ESCAPE) {\n      if (next_item === DOUBLE_QUOTE) {\n        raw += DOUBLE_QUOTE;\n        cursor.next();\n      } else if (next_item === ESCAPE) {\n        raw += ESCAPE;\n        cursor.next();\n      }\n    }\n  }\n\n  if (double_quoted || single_quoted) {\n    throw new ParseError(\n      input,\n      findPosition(input, start),\n      `Expected close of string with ${double_quoted ? DOUBLE_QUOTE : SINGLE_QUOTE}`\n    );\n  }\n\n  return {\n    type: TokenType.Literal,\n    raw,\n    loc: locate(start, cursor.index + 1)\n  };\n}\n\nfunction checkThree(input: string, current: number, check: string): false | string {\n  return (\n    input[current] === check &&\n    input[current + 1] === check &&\n    input[current + 2] === check &&\n    check\n  );\n}\n","export function iterator<T>(value: Iterable<T>): Iterator<T> {\n  return value[Symbol.iterator]();\n}\n\nexport default class Cursor<T> implements Iterator<T | undefined> {\n  iterator: Iterator<T>;\n  index: number;\n  value?: T;\n  done: boolean;\n  peeked: IteratorResult<T | undefined> | null;\n\n  constructor(iterator: Iterator<T>) {\n    this.iterator = iterator;\n    this.index = -1;\n    this.value = undefined;\n    this.done = false;\n    this.peeked = null;\n  }\n\n  next(): IteratorResult<T | undefined> {\n    if (this.done) return done();\n\n    const result = this.peeked || this.iterator.next();\n\n    this.index += 1;\n    this.value = result.value;\n    this.done = result.done;\n    this.peeked = null;\n\n    return result;\n  }\n\n  peek(): IteratorResult<T | undefined> {\n    if (this.done) return done();\n    if (this.peeked) return this.peeked;\n\n    this.peeked = this.iterator.next();\n    return this.peeked;\n  }\n\n  [Symbol.iterator]() {\n    return this;\n  }\n}\n\nfunction done(): IteratorResult<undefined> {\n  return { value: undefined, done: true };\n}\n","export interface Location {\n  start: Position;\n  end: Position;\n}\n\nexport interface Position {\n  // Note: line is 1-indexed while column is 0-indexed\n  line: number;\n  column: number;\n}\n\nexport interface Span {\n  lines: number;\n  columns: number;\n}\n\nexport function getSpan(location: Location): Span {\n  return {\n    lines: location.end.line - location.start.line + 1,\n    columns: location.end.column - location.start.column\n  };\n}\n\nexport type Locator = (start: number, end: number) => Location;\nexport function createLocate(input: string): Locator {\n  const lines = findLines(input);\n\n  return (start: number, end: number) => {\n    return {\n      start: findPosition(lines, start),\n      end: findPosition(lines, end)\n    };\n  };\n}\n\nexport function findPosition(input: string | number[], index: number): Position {\n  // abc\\ndef\\ng\n  // 0123 4567 8\n  //      012\n  //           0\n  //\n  // lines = [3, 7, 9]\n  //\n  // c = 2: 0 -> 1, 2 - (undefined + 1 || 0) = 2\n  //     3: 0 -> 1, 3 - (undefined + 1 || 0) = 3\n  // e = 5: 1 -> 2, 5 - (3 + 1 || 0) = 1\n  // g = 8: 2 -> 3, 8 - (7 + 1 || 0) = 0\n\n  const lines = Array.isArray(input) ? input : findLines(input);\n  const line = lines.findIndex(line_index => line_index >= index) + 1;\n  const column = index - (lines[line - 2] + 1 || 0);\n\n  return { line, column };\n}\n\nexport function getLine(input: string, position: Position): string {\n  const lines = findLines(input);\n  const start = lines[position.line - 2] || 0;\n  const end = lines[position.line - 1] || input.length;\n\n  return input.substr(start, end - start);\n}\n\nexport function findLines(input: string): number[] {\n  // exec is stateful, so create new regexp each time\n  const BY_NEW_LINE = /[\\r\\n|\\n]/g;\n  const indexes: number[] = [];\n\n  let match;\n  while ((match = BY_NEW_LINE.exec(input)) != null) {\n    indexes.push(match.index);\n  }\n  indexes.push(input.length + 1);\n\n  return indexes;\n}\n\nexport function clonePosition(position: Position): Position {\n  return { line: position.line, column: position.column };\n}\n\nexport function cloneLocation(location: Location): Location {\n  return { start: clonePosition(location.start), end: clonePosition(location.end) };\n}\n\nexport function zero(): Position {\n  return { line: 1, column: 0 };\n}\n","import { Position, getLine } from './location';\n\nexport default class ParseError extends Error {\n  line: number;\n  column: number;\n\n  constructor(input: string, position: Position, message: string) {\n    let error_message = `Error parsing TOML (${position.line}, ${position.column + 1}):\\n`;\n\n    if (input) {\n      const line = getLine(input, position);\n      const pointer = `${whitespace(position.column)}^`;\n\n      if (line) error_message += `${line}\\n${pointer}\\n`;\n    }\n    error_message += message;\n\n    super(error_message);\n\n    this.line = position.line;\n    this.column = position.column;\n  }\n}\n\nexport function isParseError(error: Error): error is ParseError {\n  return error && Object.prototype.hasOwnProperty.call(error, 'line');\n}\n\nfunction whitespace(count: number, character: string = ' '): string {\n  return character.repeat(count);\n}\n","export function last<TValue>(values: TValue[]): TValue | undefined {\n  return values[values.length - 1];\n}\n\nexport type BlankObject = { [key: string]: any };\n\nexport function blank(): BlankObject {\n  return Object.create(null);\n}\n\nexport function isString(value: any): value is string {\n  return typeof value === 'string';\n}\n\nexport function isInteger(value: any): value is number {\n  return typeof value === 'number' && value % 1 === 0;\n}\n\nexport function isFloat(value: any): value is number {\n  return typeof value === 'number' && !isInteger(value);\n}\n\nexport function isBoolean(value: any): value is boolean {\n  return typeof value === 'boolean';\n}\n\nexport function isDate(value: any): value is Date {\n  return Object.prototype.toString.call(value) === '[object Date]';\n}\n\nexport function isObject(value: any): boolean {\n  return value && typeof value === 'object' && !isDate(value) && !Array.isArray(value);\n}\n\nexport function isIterable<T>(value: any): value is Iterable<T> {\n  return value != null && typeof value[Symbol.iterator] === 'function';\n}\n\nexport function has(object: any, key: string): boolean {\n  return Object.prototype.hasOwnProperty.call(object, key);\n}\n\nexport function arraysEqual<TItem>(a: TItem[], b: TItem[]): boolean {\n  if (a.length !== b.length) return false;\n\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n\n  return true;\n}\n\nexport function datesEqual(a: any, b: any): boolean {\n  return isDate(a) && isDate(b) && a.toISOString() === b.toISOString();\n}\n\nexport function pipe<TValue>(value: TValue, ...fns: Array<(value: TValue) => TValue>): TValue {\n  return fns.reduce((value, fn) => fn(value), value);\n}\n\nexport function stableStringify(object: any): string {\n  if (isObject(object)) {\n    const key_values = Object.keys(object)\n      .sort()\n      .map(key => `${JSON.stringify(key)}:${stableStringify(object[key])}`);\n\n    return `{${key_values.join(',')}}`;\n  } else if (Array.isArray(object)) {\n    return `[${object.map(stableStringify).join(',')}]`;\n  } else {\n    return JSON.stringify(object);\n  }\n}\n\nexport function merge<TValue>(target: TValue[], values: TValue[]) {\n  // __mutating__: merge values into target\n  // Reference: https://dev.to/uilicious/javascript-array-push-is-945x-faster-than-array-concat-1oki\n  const original_length = target.length;\n  const added_length = values.length;\n  target.length = original_length + added_length;\n\n  for (let i = 0; i < added_length; i++) {\n    target[original_length + i] = values[i];\n  }\n}\n","import { SINGLE_QUOTE, DOUBLE_QUOTE } from './tokenizer';\nimport { pipe } from './utils';\n\nconst TRIPLE_DOUBLE_QUOTE = `\"\"\"`;\nconst TRIPLE_SINGLE_QUOTE = `'''`;\nconst LF = '\\\\n';\nconst CRLF = '\\\\r\\\\n';\nconst IS_CRLF = /\\r\\n/g;\nconst IS_LF = /\\n/g;\nconst IS_LEADING_NEW_LINE = /^(\\r\\n|\\n)/;\nconst IS_LINE_ENDING_BACKSLASH = /\\\\\\s*[\\n\\r\\n]\\s*/g;\n\nexport function parseString(raw: string): string {\n  if (raw.startsWith(TRIPLE_SINGLE_QUOTE)) {\n    return pipe(\n      trim(raw, 3),\n      trimLeadingWhitespace\n    );\n  } else if (raw.startsWith(SINGLE_QUOTE)) {\n    return trim(raw, 1);\n  } else if (raw.startsWith(TRIPLE_DOUBLE_QUOTE)) {\n    return pipe(\n      trim(raw, 3),\n      trimLeadingWhitespace,\n      lineEndingBackslash,\n      escapeNewLines,\n      unescape\n    );\n  } else if (raw.startsWith(DOUBLE_QUOTE)) {\n    return pipe(\n      trim(raw, 1),\n      unescape\n    );\n  } else {\n    return raw;\n  }\n}\n\nexport function unescape(escaped: string): string {\n  // JSON.parse handles everything except \\UXXXXXXXX\n  // replace those instances with code point, escape that, and then parse\n  const LARGE_UNICODE = /\\\\U[a-fA-F0-9]{8}/g;\n  const json_escaped = escaped.replace(LARGE_UNICODE, value => {\n    const code_point = parseInt(value.replace('\\\\U', ''), 16);\n    const as_string = String.fromCodePoint(code_point);\n\n    return trim(JSON.stringify(as_string), 1);\n  });\n\n  return JSON.parse(`\"${json_escaped}\"`);\n}\n\nexport function escape(value: string): string {\n  return trim(JSON.stringify(value), 1);\n}\n\nfunction trim(value: string, count: number): string {\n  return value.substr(count, value.length - count * 2);\n}\n\nfunction trimLeadingWhitespace(value: string): string {\n  return IS_LEADING_NEW_LINE.test(value) ? value.substr(1) : value;\n}\n\nfunction escapeNewLines(value: string): string {\n  return value.replace(IS_CRLF, CRLF).replace(IS_LF, LF);\n}\n\nfunction lineEndingBackslash(value: string): string {\n  return value.replace(IS_LINE_ENDING_BACKSLASH, '');\n}\n","import {\n  NodeType,\n  KeyValue,\n  Table,\n  TableKey,\n  TableArray,\n  TableArrayKey,\n  Key,\n  Value,\n  String,\n  Integer,\n  Float,\n  Boolean,\n  DateTime,\n  InlineTable,\n  InlineArray,\n  InlineItem,\n  Comment,\n  AST,\n  Block\n} from './ast';\nimport { Token, TokenType, tokenize, DOUBLE_QUOTE, SINGLE_QUOTE } from './tokenizer';\nimport { parseString } from './parse-string';\nimport Cursor from './cursor';\nimport { clonePosition, cloneLocation } from './location';\nimport ParseError from './parse-error';\nimport { merge } from './utils';\n\nconst TRUE = 'true';\nconst FALSE = 'false';\nconst HAS_E = /e/i;\nconst IS_DIVIDER = /\\_/g;\nconst IS_INF = /inf/;\nconst IS_NAN = /nan/;\nconst IS_HEX = /^0x/;\nconst IS_OCTAL = /^0o/;\nconst IS_BINARY = /^0b/;\nexport const IS_FULL_DATE = /(\\d{4})-(\\d{2})-(\\d{2})/;\nexport const IS_FULL_TIME = /(\\d{2}):(\\d{2}):(\\d{2})/;\n\nexport default function* parseTOML(input: string): AST {\n  const tokens = tokenize(input);\n  const cursor = new Cursor(tokens);\n\n  while (!cursor.next().done) {\n    yield* walkBlock(cursor, input);\n  }\n}\n\nfunction* walkBlock(cursor: Cursor<Token>, input: string): IterableIterator<Block> {\n  if (cursor.value!.type === TokenType.Comment) {\n    yield comment(cursor);\n  } else if (cursor.value!.type === TokenType.Bracket) {\n    yield table(cursor, input);\n  } else if (cursor.value!.type === TokenType.Literal) {\n    yield* keyValue(cursor, input);\n  } else {\n    throw new ParseError(\n      input,\n      cursor.value!.loc.start,\n      `Unexpected token \"${cursor.value!.type}\". Expected Comment, Bracket, or String`\n    );\n  }\n}\n\nfunction* walkValue(cursor: Cursor<Token>, input: string): IterableIterator<Value | Comment> {\n  if (cursor.value!.type === TokenType.Literal) {\n    if (cursor.value!.raw[0] === DOUBLE_QUOTE || cursor.value!.raw[0] === SINGLE_QUOTE) {\n      yield string(cursor);\n    } else if (cursor.value!.raw === TRUE || cursor.value!.raw === FALSE) {\n      yield boolean(cursor);\n    } else if (IS_FULL_DATE.test(cursor.value!.raw) || IS_FULL_TIME.test(cursor.value!.raw)) {\n      yield datetime(cursor, input);\n    } else if (\n      (!cursor.peek().done && cursor.peek().value!.type === TokenType.Dot) ||\n      IS_INF.test(cursor.value!.raw) ||\n      IS_NAN.test(cursor.value!.raw) ||\n      (HAS_E.test(cursor.value!.raw) && !IS_HEX.test(cursor.value!.raw))\n    ) {\n      yield float(cursor, input);\n    } else {\n      yield integer(cursor);\n    }\n  } else if (cursor.value!.type === TokenType.Curly) {\n    yield inlineTable(cursor, input);\n  } else if (cursor.value!.type === TokenType.Bracket) {\n    const [inline_array, comments] = inlineArray(cursor, input);\n\n    yield inline_array;\n    yield* comments;\n  } else {\n    throw new ParseError(\n      input,\n      cursor.value!.loc.start,\n      `Unrecognized token type \"${cursor.value!.type}\". Expected String, Curly, or Bracket`\n    );\n  }\n}\n\nfunction comment(cursor: Cursor<Token>): Comment {\n  // # line comment\n  // ^------------^ Comment\n  return {\n    type: NodeType.Comment,\n    loc: cursor.value!.loc,\n    raw: cursor.value!.raw\n  };\n}\n\nfunction table(cursor: Cursor<Token>, input: string): Table | TableArray {\n  // Table or TableArray\n  //\n  // [ key ]\n  // ^-----^    TableKey\n  //   ^-^      Key\n  //\n  // [[ key ]]\n  // ^ ------^  TableArrayKey\n  //    ^-^     Key\n  //\n  // a = \"b\"  < Items\n  // # c      |\n  // d = \"f\"  <\n  //\n  // ...\n  const type =\n    !cursor.peek().done && cursor.peek().value!.type === TokenType.Bracket\n      ? NodeType.TableArray\n      : NodeType.Table;\n  const is_table = type === NodeType.Table;\n\n  if (is_table && cursor.value!.raw !== '[') {\n    throw new ParseError(\n      input,\n      cursor.value!.loc.start,\n      `Expected table opening \"[\", found ${cursor.value!.raw}`\n    );\n  }\n  if (!is_table && (cursor.value!.raw !== '[' || cursor.peek().value!.raw !== '[')) {\n    throw new ParseError(\n      input,\n      cursor.value!.loc.start,\n      `Expected array of tables opening \"[[\", found ${cursor.value!.raw + cursor.peek().value!.raw}`\n    );\n  }\n\n  // Set start location from opening tag\n  const key = is_table\n    ? ({\n        type: NodeType.TableKey,\n        loc: cursor.value!.loc\n      } as Partial<TableKey>)\n    : ({\n        type: NodeType.TableArrayKey,\n        loc: cursor.value!.loc\n      } as Partial<TableArrayKey>);\n\n  // Skip to cursor.value for key value\n  cursor.next();\n  if (type === NodeType.TableArray) cursor.next();\n\n  if (cursor.done) {\n    throw new ParseError(input, key.loc!.start, `Expected table key, reached end of file`);\n  }\n\n  key.item = {\n    type: NodeType.Key,\n    loc: cloneLocation(cursor.value!.loc),\n    raw: cursor.value!.raw,\n    value: [parseString(cursor.value!.raw)]\n  };\n\n  while (!cursor.peek().done && cursor.peek().value!.type === TokenType.Dot) {\n    cursor.next();\n    const dot = cursor.value!;\n\n    cursor.next();\n    const before = ' '.repeat(dot.loc.start.column - key.item.loc.end.column);\n    const after = ' '.repeat(cursor.value!.loc.start.column - dot.loc.end.column);\n\n    key.item.loc.end = cursor.value!.loc.end;\n    key.item.raw += `${before}.${after}${cursor.value!.raw}`;\n    key.item.value.push(parseString(cursor.value!.raw));\n  }\n\n  cursor.next();\n\n  if (is_table && (cursor.done || cursor.value!.raw !== ']')) {\n    throw new ParseError(\n      input,\n      cursor.done ? key.item.loc.end : cursor.value!.loc.start,\n      `Expected table closing \"]\", found ${cursor.done ? 'end of file' : cursor.value!.raw}`\n    );\n  }\n  if (\n    !is_table &&\n    (cursor.done ||\n      cursor.peek().done ||\n      cursor.value!.raw !== ']' ||\n      cursor.peek().value!.raw !== ']')\n  ) {\n    throw new ParseError(\n      input,\n      cursor.done || cursor.peek().done ? key.item.loc.end : cursor.value!.loc.start,\n      `Expected array of tables closing \"]]\", found ${\n        cursor.done || cursor.peek().done\n          ? 'end of file'\n          : cursor.value!.raw + cursor.peek().value!.raw\n      }`\n    );\n  }\n\n  // Set end location from closing tag\n  if (!is_table) cursor.next();\n  key.loc!.end = cursor.value!.loc.end;\n\n  // Add child items\n  let items: Array<KeyValue | Comment> = [];\n  while (!cursor.peek().done && cursor.peek().value!.type !== TokenType.Bracket) {\n    cursor.next();\n    merge(items, [...walkBlock(cursor, input)] as Array<KeyValue | Comment>);\n  }\n\n  return {\n    type: is_table ? NodeType.Table : NodeType.TableArray,\n    loc: {\n      start: clonePosition(key.loc!.start),\n      end: items.length\n        ? clonePosition(items[items.length - 1].loc.end)\n        : clonePosition(key.loc!.end)\n    },\n    key: key as TableKey | TableArrayKey,\n    items\n  } as Table | TableArray;\n}\n\nfunction keyValue(cursor: Cursor<Token>, input: string): Array<KeyValue | Comment> {\n  // 3. KeyValue\n  //\n  // key = value\n  // ^-^          key\n  //     ^        equals\n  //       ^---^  value\n  const key: Key = {\n    type: NodeType.Key,\n    loc: cloneLocation(cursor.value!.loc),\n    raw: cursor.value!.raw,\n    value: [parseString(cursor.value!.raw)]\n  };\n\n  while (!cursor.peek().done && cursor.peek().value!.type === TokenType.Dot) {\n    cursor.next();\n    cursor.next();\n\n    key.loc.end = cursor.value!.loc.end;\n    key.raw += `.${cursor.value!.raw}`;\n    key.value.push(parseString(cursor.value!.raw));\n  }\n\n  cursor.next();\n\n  if (cursor.done || cursor.value!.type !== TokenType.Equal) {\n    throw new ParseError(\n      input,\n      cursor.done ? key.loc.end : cursor.value!.loc.start,\n      `Expected \"=\" for key-value, found ${cursor.done ? 'end of file' : cursor.value!.raw}`\n    );\n  }\n\n  const equals = cursor.value!.loc.start.column;\n\n  cursor.next();\n\n  if (cursor.done) {\n    throw new ParseError(input, key.loc.start, `Expected value for key-value, reached end of file`);\n  }\n\n  const [value, ...comments] = walkValue(cursor, input) as Iterable<Value | Comment>;\n\n  return [\n    {\n      type: NodeType.KeyValue,\n      key,\n      value: value as Value,\n      loc: {\n        start: clonePosition(key.loc.start),\n        end: clonePosition(value.loc.end)\n      },\n      equals\n    },\n    ...(comments as Comment[])\n  ];\n}\n\nfunction string(cursor: Cursor<Token>): String {\n  return {\n    type: NodeType.String,\n    loc: cursor.value!.loc,\n    raw: cursor.value!.raw,\n    value: parseString(cursor.value!.raw)\n  };\n}\n\nfunction boolean(cursor: Cursor<Token>): Boolean {\n  return {\n    type: NodeType.Boolean,\n    loc: cursor.value!.loc,\n    value: cursor.value!.raw === TRUE\n  };\n}\n\nfunction datetime(cursor: Cursor<Token>, input: string): DateTime {\n  // Possible values:\n  //\n  // Offset Date-Time\n  // | odt1 = 1979-05-27T07:32:00Z\n  // | odt2 = 1979-05-27T00:32:00-07:00\n  // | odt3 = 1979-05-27T00:32:00.999999-07:00\n  // | odt4 = 1979-05-27 07:32:00Z\n  //\n  // Local Date-Time\n  // | ldt1 = 1979-05-27T07:32:00\n  // | ldt2 = 1979-05-27T00:32:00.999999\n  //\n  // Local Date\n  // | ld1 = 1979-05-27\n  //\n  // Local Time\n  // | lt1 = 07:32:00\n  // | lt2 = 00:32:00.999999\n  let loc = cursor.value!.loc;\n  let raw = cursor.value!.raw;\n  let value: Date;\n\n  // If next token is string,\n  // check if raw is full date and following is full time\n  if (\n    !cursor.peek().done &&\n    cursor.peek().value!.type === TokenType.Literal &&\n    IS_FULL_DATE.test(raw) &&\n    IS_FULL_TIME.test(cursor.peek().value!.raw)\n  ) {\n    const start = loc.start;\n\n    cursor.next();\n    loc = { start, end: cursor.value!.loc.end };\n    raw += ` ${cursor.value!.raw}`;\n  }\n\n  if (!cursor.peek().done && cursor.peek().value!.type === TokenType.Dot) {\n    const start = loc.start;\n\n    cursor.next();\n\n    if (cursor.peek().done || cursor.peek().value!.type !== TokenType.Literal) {\n      throw new ParseError(input, cursor.value!.loc.end, `Expected fractional value for DateTime`);\n    }\n    cursor.next();\n\n    loc = { start, end: cursor.value!.loc.end };\n    raw += `.${cursor.value!.raw}`;\n  }\n\n  if (!IS_FULL_DATE.test(raw)) {\n    // For local time, use local ISO date\n    const [local_date] = new Date().toISOString().split('T');\n    value = new Date(`${local_date}T${raw}`);\n  } else {\n    value = new Date(raw.replace(' ', 'T'));\n  }\n\n  return {\n    type: NodeType.DateTime,\n    loc,\n    raw,\n    value\n  };\n}\n\nfunction float(cursor: Cursor<Token>, input: string): Float {\n  let loc = cursor.value!.loc;\n  let raw = cursor.value!.raw;\n  let value;\n\n  if (IS_INF.test(raw)) {\n    value = raw === '-inf' ? -Infinity : Infinity;\n  } else if (IS_NAN.test(raw)) {\n    value = raw === '-nan' ? -NaN : NaN;\n  } else if (!cursor.peek().done && cursor.peek().value!.type === TokenType.Dot) {\n    const start = loc.start;\n\n    // From spec:\n    // | A fractional part is a decimal point followed by one or more digits.\n    //\n    // -> Don't have to handle \"4.\" (i.e. nothing behind decimal place)\n\n    cursor.next();\n\n    if (cursor.peek().done || cursor.peek().value!.type !== TokenType.Literal) {\n      throw new ParseError(input, cursor.value!.loc.end, `Expected fraction value for Float`);\n    }\n    cursor.next();\n\n    raw += `.${cursor.value!.raw}`;\n    loc = { start, end: cursor.value!.loc.end };\n    value = Number(raw.replace(IS_DIVIDER, ''));\n  } else {\n    value = Number(raw.replace(IS_DIVIDER, ''));\n  }\n\n  return { type: NodeType.Float, loc, raw, value };\n}\n\nfunction integer(cursor: Cursor<Token>): Integer {\n  // > Integer values -0 and +0 are valid and identical to an unprefixed zero\n  if (cursor.value!.raw === '-0' || cursor.value!.raw === '+0') {\n    return {\n      type: NodeType.Integer,\n      loc: cursor.value!.loc,\n      raw: cursor.value!.raw,\n      value: 0\n    };\n  }\n\n  let radix = 10;\n  if (IS_HEX.test(cursor.value!.raw)) {\n    radix = 16;\n  } else if (IS_OCTAL.test(cursor.value!.raw)) {\n    radix = 8;\n  } else if (IS_BINARY.test(cursor.value!.raw)) {\n    radix = 2;\n  }\n\n  const value = parseInt(\n    cursor\n      .value!.raw.replace(IS_DIVIDER, '')\n      .replace(IS_OCTAL, '')\n      .replace(IS_BINARY, ''),\n    radix\n  );\n\n  return {\n    type: NodeType.Integer,\n    loc: cursor.value!.loc,\n    raw: cursor.value!.raw,\n    value\n  };\n}\n\nfunction inlineTable(cursor: Cursor<Token>, input: string): InlineTable {\n  if (cursor.value!.raw !== '{') {\n    throw new ParseError(\n      input,\n      cursor.value!.loc.start,\n      `Expected \"{\" for inline table, found ${cursor.value!.raw}`\n    );\n  }\n\n  // 6. InlineTable\n  const value: InlineTable = {\n    type: NodeType.InlineTable,\n    loc: cloneLocation(cursor.value!.loc),\n    items: []\n  };\n\n  cursor.next();\n\n  while (\n    !cursor.done &&\n    !(cursor.value!.type === TokenType.Curly && (cursor.value as Token).raw === '}')\n  ) {\n    if ((cursor.value as Token).type === TokenType.Comma) {\n      const previous = value.items[value.items.length - 1];\n      if (!previous) {\n        throw new ParseError(\n          input,\n          cursor.value!.loc.start,\n          'Found \",\" without previous value in inline table'\n        );\n      }\n\n      previous.comma = true;\n      previous.loc.end = cursor.value!.loc.start;\n\n      cursor.next();\n      continue;\n    }\n\n    const [item] = walkBlock(cursor, input);\n    if (item.type !== NodeType.KeyValue) {\n      throw new ParseError(\n        input,\n        cursor.value!.loc.start,\n        `Only key-values are supported in inline tables, found ${item.type}`\n      );\n    }\n\n    const inline_item: InlineItem<KeyValue> = {\n      type: NodeType.InlineItem,\n      loc: cloneLocation(item.loc),\n      item,\n      comma: false\n    };\n\n    value.items.push(inline_item);\n    cursor.next();\n  }\n\n  if (\n    cursor.done ||\n    cursor.value!.type !== TokenType.Curly ||\n    (cursor.value as Token).raw !== '}'\n  ) {\n    throw new ParseError(\n      input,\n      cursor.done ? value.loc.start : cursor.value!.loc.start,\n      `Expected \"}\", found ${cursor.done ? 'end of file' : cursor.value!.raw}`\n    );\n  }\n\n  value.loc.end = cursor.value!.loc.end;\n\n  return value;\n}\n\nfunction inlineArray(cursor: Cursor<Token>, input: string): [InlineArray, Comment[]] {\n  // 7. InlineArray\n  if (cursor.value!.raw !== '[') {\n    throw new ParseError(\n      input,\n      cursor.value!.loc.start,\n      `Expected \"[\" for inline array, found ${cursor.value!.raw}`\n    );\n  }\n\n  const value: InlineArray = {\n    type: NodeType.InlineArray,\n    loc: cloneLocation(cursor.value!.loc),\n    items: []\n  };\n  let comments: Comment[] = [];\n\n  cursor.next();\n\n  while (\n    !cursor.done &&\n    !(cursor.value!.type === TokenType.Bracket && (cursor.value as Token).raw === ']')\n  ) {\n    if ((cursor.value as Token).type === TokenType.Comma) {\n      const previous = value.items[value.items.length - 1];\n      if (!previous) {\n        throw new ParseError(\n          input,\n          cursor.value!.loc.start,\n          'Found \",\" without previous value for inline array'\n        );\n      }\n\n      previous.comma = true;\n      previous.loc.end = cursor.value!.loc.start;\n    } else if ((cursor.value as Token).type === TokenType.Comment) {\n      comments.push(comment(cursor));\n    } else {\n      const [item, ...additional_comments] = walkValue(cursor, input);\n      const inline_item: InlineItem = {\n        type: NodeType.InlineItem,\n        loc: cloneLocation(item.loc),\n        item,\n        comma: false\n      };\n\n      value.items.push(inline_item);\n      merge(comments, additional_comments as Comment[]);\n    }\n\n    cursor.next();\n  }\n\n  if (\n    cursor.done ||\n    cursor.value!.type !== TokenType.Bracket ||\n    (cursor.value as Token).raw !== ']'\n  ) {\n    throw new ParseError(\n      input,\n      cursor.done ? value.loc.start : cursor.value!.loc.start,\n      `Expected \"]\", found ${cursor.done ? 'end of file' : cursor.value!.raw}`\n    );\n  }\n\n  value.loc.end = cursor.value!.loc.end;\n\n  return [value, comments];\n}\n","import {\n  NodeType,\n  AST,\n  Node,\n  Document,\n  Table,\n  TableKey,\n  TableArray,\n  TableArrayKey,\n  KeyValue,\n  Key,\n  String,\n  Integer,\n  Float,\n  Boolean,\n  DateTime,\n  Comment,\n  InlineArray,\n  InlineTable,\n  InlineItem\n} from './ast';\nimport { isIterable } from './utils';\n\nexport type Visit<TNode = Node> = (node: TNode, parent: TNode | null) => void;\nexport type EnterExit<TNode = Node> = { enter?: Visit<TNode>; exit?: Visit<TNode> };\n\nexport type Visitor = {\n  Document?: Visit<Document> | EnterExit<Document>;\n  Table?: Visit<Table> | EnterExit<Table>;\n  TableKey?: Visit<TableKey> | EnterExit<TableKey>;\n  TableArray?: Visit<TableArray> | EnterExit<TableArray>;\n  TableArrayKey?: Visit<TableArrayKey> | EnterExit<TableArrayKey>;\n  KeyValue?: Visit<KeyValue> | EnterExit<KeyValue>;\n  Key?: Visit<Key> | EnterExit<Key>;\n  String?: Visit<String> | EnterExit<String>;\n  Integer?: Visit<Integer> | EnterExit<Integer>;\n  Float?: Visit<Float> | EnterExit<Float>;\n  Boolean?: Visit<Boolean> | EnterExit<Boolean>;\n  DateTime?: Visit<DateTime> | EnterExit<DateTime>;\n  InlineArray?: Visit<InlineArray> | EnterExit<InlineArray>;\n  InlineItem?: Visit<InlineItem> | EnterExit<InlineItem>;\n  InlineTable?: Visit<InlineTable> | EnterExit<InlineTable>;\n  Comment?: Visit<Comment> | EnterExit<Comment>;\n};\n\nexport default function traverse(ast: AST | Node, visitor: Visitor) {\n  if (isIterable(ast)) {\n    traverseArray(ast, null);\n  } else {\n    traverseNode(ast, null);\n  }\n\n  function traverseArray(array: Iterable<Node>, parent: Node | null) {\n    for (const node of array) {\n      traverseNode(node, parent);\n    }\n  }\n\n  function traverseNode(node: Node, parent: Node | null) {\n    const visit = visitor[node.type];\n\n    if (visit && typeof visit === 'function') {\n      (visit as Visit)(node, parent);\n    }\n    if (visit && (visit as EnterExit).enter) {\n      (visit as EnterExit).enter!(node, parent);\n    }\n\n    switch (node.type) {\n      case NodeType.Document:\n        traverseArray((node as Document).items, node);\n        break;\n\n      case NodeType.Table:\n        traverseNode((node as Table).key, node);\n        traverseArray((node as Table).items, node);\n        break;\n      case NodeType.TableKey:\n        traverseNode((node as TableKey).item, node);\n        break;\n\n      case NodeType.TableArray:\n        traverseNode((node as TableArray).key, node);\n        traverseArray((node as TableArray).items, node);\n        break;\n      case NodeType.TableArrayKey:\n        traverseNode((node as TableArrayKey).item, node);\n        break;\n\n      case NodeType.KeyValue:\n        traverseNode((node as KeyValue).key, node);\n        traverseNode((node as KeyValue).value, node);\n        break;\n\n      case NodeType.InlineArray:\n        traverseArray((node as InlineArray).items, node);\n        break;\n      case NodeType.InlineItem:\n        traverseNode((node as InlineItem).item, node);\n        break;\n\n      case NodeType.InlineTable:\n        traverseArray((node as InlineTable).items, node);\n        break;\n\n      case NodeType.Key:\n      case NodeType.String:\n      case NodeType.Integer:\n      case NodeType.Float:\n      case NodeType.Boolean:\n      case NodeType.DateTime:\n      case NodeType.Comment:\n        break;\n\n      default:\n        throw new Error(`Unrecognized node type \"${node.type}\"`);\n    }\n\n    if (visit && (visit as EnterExit).exit) {\n      (visit as EnterExit).exit!(node, parent);\n    }\n  }\n}\n","import {\n  NodeType,\n  Node,\n  Document,\n  Key,\n  Value,\n  InlineArray,\n  InlineArrayItem,\n  InlineTableItem,\n  isKeyValue,\n  isTable,\n  isTableArray,\n  isInlineTable,\n  isInlineArray,\n  hasItems,\n  hasItem,\n  isComment,\n  isDocument,\n  InlineTable,\n  TableArray,\n  Table,\n  KeyValue,\n  Comment,\n  InlineItem,\n  isInlineItem,\n  Block,\n  isBlock\n} from './ast';\nimport { Span, getSpan, clonePosition } from './location';\nimport { last } from './utils';\nimport traverse from './traverse';\n\nexport type Root = Document | Node;\n\n// Store line and column offsets per node\n//\n// Some offsets are applied on enter (e.g. shift child items and next items)\n// Others are applied on exit (e.g. shift next items)\ntype Offsets = WeakMap<Node, Span>;\n\nconst enter_offsets: WeakMap<Root, Offsets> = new WeakMap();\nconst getEnter = (root: Root) => {\n  if (!enter_offsets.has(root)) {\n    enter_offsets.set(root, new WeakMap());\n  }\n  return enter_offsets.get(root)!;\n};\n\nconst exit_offsets: WeakMap<Root, Offsets> = new WeakMap();\nconst getExit = (root: Root) => {\n  if (!exit_offsets.has(root)) {\n    exit_offsets.set(root, new WeakMap());\n  }\n  return exit_offsets.get(root)!;\n};\n\nexport function replace(root: Root, parent: Node, existing: Node, replacement: Node) {\n  // First, replace existing node\n  // (by index for items, item, or key/value)\n  if (hasItems(parent)) {\n    const index = parent.items.indexOf(existing);\n    if (index < 0) throw new Error(`Could not find existing item in parent node for replace`);\n\n    parent.items.splice(index, 1, replacement);\n  } else if (hasItem(parent)) {\n    parent.item = replacement;\n  } else if (isKeyValue(parent)) {\n    if (parent.key === existing) {\n      parent.key = replacement as Key;\n    } else {\n      parent.value = replacement as Value;\n    }\n  } else {\n    throw new Error(`Unsupported parent type \"${parent.type}\" for replace`);\n  }\n\n  // Shift the replacement node into the same start position as existing\n  const shift = {\n    lines: existing.loc.start.line - replacement.loc.start.line,\n    columns: existing.loc.start.column - replacement.loc.start.column\n  };\n  shiftNode(replacement, shift);\n\n  // Apply offsets after replacement node\n  const existing_span = getSpan(existing.loc);\n  const replacement_span = getSpan(replacement.loc);\n  const offset = {\n    lines: replacement_span.lines - existing_span.lines,\n    columns: replacement_span.columns - existing_span.columns\n  };\n\n  addOffset(offset, getExit(root), replacement, existing);\n}\n\nexport function insert(root: Root, parent: Node, child: Node, index?: number) {\n  if (!hasItems(parent)) {\n    throw new Error(`Unsupported parent type \"${(parent as Node).type}\" for insert`);\n  }\n\n  index = index != null ? index : parent.items.length;\n\n  let shift: Span;\n  let offset: Span;\n  if (isInlineArray(parent) || isInlineTable(parent)) {\n    ({ shift, offset } = insertInline(parent, child as InlineItem, index));\n  } else {\n    ({ shift, offset } = insertOnNewLine(\n      parent as Document | Table | TableArray,\n      child as KeyValue | Comment,\n      index\n    ));\n  }\n\n  shiftNode(child, shift);\n\n  // The child element is placed relative to the previous element,\n  // if the previous element has an offset, need to position relative to that\n  // -> Move previous offset to child's offset\n  const previous = parent.items[index - 1];\n  const previous_offset = previous && getExit(root).get(previous);\n  if (previous_offset) {\n    offset.lines += previous_offset.lines;\n    offset.columns += previous_offset.columns;\n\n    // Account for comma overlay\n    //\n    // a = [b, e]\n    // a = [b, c, e]\n    //       ^---^\n    // a = [b, c, d, e]\n    //          ^---^\n    if (isInlineItem(child) && previous && parent.items[index + 1]) {\n      offset.columns -= 2;\n    }\n\n    getExit(root).delete(previous!);\n  }\n\n  const offsets = getExit(root);\n  offsets.set(child, offset);\n}\n\nfunction insertOnNewLine(\n  parent: Document | Table | TableArray,\n  child: Block,\n  index: number\n): { shift: Span; offset: Span } {\n  if (!isBlock(child)) {\n    throw new Error(`Incompatible child type \"${(child as Node).type}\"`);\n  }\n\n  const previous = parent.items[index - 1];\n  const use_first_line = isDocument(parent) && !parent.items.length;\n\n  parent.items.splice(index, 0, child);\n\n  // Set start location from previous item or start of array\n  // (previous is undefined for empty array or inserting at first item)\n  const start = previous\n    ? {\n        line: previous.loc.end.line,\n        column: !isComment(previous) ? previous.loc.start.column : parent.loc.start.column\n      }\n    : clonePosition(parent.loc.start);\n\n  const is_block = isTable(child) || isTableArray(child);\n  let leading_lines = 0;\n  if (use_first_line) {\n    // 0 leading lines\n  } else if (is_block) {\n    leading_lines = 2;\n  } else {\n    leading_lines = 1;\n  }\n  start.line += leading_lines;\n\n  const shift = {\n    lines: start.line - child.loc.start.line,\n    columns: start.column - child.loc.start.column\n  };\n\n  // Apply offsets after child node\n  const child_span = getSpan(child.loc);\n  const offset = {\n    lines: child_span.lines + (leading_lines - 1),\n    columns: child_span.columns\n  };\n\n  return { shift, offset };\n}\n\nfunction insertInline(\n  parent: InlineArray | InlineTable,\n  child: InlineItem,\n  index: number\n): { shift: Span; offset: Span } {\n  if (!isInlineItem(child)) {\n    throw new Error(`Incompatible child type \"${(child as Node).type}\"`);\n  }\n\n  // Store preceding node and insert\n  const previous = index != null ? parent.items[index - 1] : last(parent.items);\n  const is_last = index == null || index === parent.items.length;\n\n  parent.items.splice(index, 0, child);\n\n  // Add commas as-needed\n  const leading_comma = !!previous;\n  const trailing_comma = !is_last;\n  const last_comma = is_last && child.comma === true;\n  if (leading_comma) {\n    previous!.comma = true;\n  }\n  if (trailing_comma) {\n    child.comma = true;\n  }\n\n  // Use a new line for documents, children of Table/TableArray,\n  // and if an inline table is using new lines\n  const use_new_line = isInlineArray(parent) && perLine(parent);\n\n  // Set start location from previous item or start of array\n  // (previous is undefined for empty array or inserting at first item)\n  const start = previous\n    ? {\n        line: previous.loc.end.line,\n        column: use_new_line\n          ? !isComment(previous)\n            ? previous.loc.start.column\n            : parent.loc.start.column\n          : previous.loc.end.column\n      }\n    : clonePosition(parent.loc.start);\n\n  let leading_lines = 0;\n  if (use_new_line) {\n    leading_lines = 1;\n  } else {\n    const skip_comma = 2;\n    const skip_bracket = 1;\n    start.column += leading_comma ? skip_comma : skip_bracket;\n  }\n  start.line += leading_lines;\n\n  const shift = {\n    lines: start.line - child.loc.start.line,\n    columns: start.column - child.loc.start.column\n  };\n\n  // Apply offsets after child node\n  const child_span = getSpan(child.loc);\n  const offset = {\n    lines: child_span.lines + (leading_lines - 1),\n    columns: child_span.columns + (leading_comma || trailing_comma ? 2 : 0) + (last_comma ? 1 : 0)\n  };\n\n  return { shift, offset };\n}\n\nexport function remove(root: Root, parent: Node, node: Node) {\n  // Remove an element from the parent's items\n  // (supports Document, Table, TableArray, InlineTable, and InlineArray\n  //\n  //      X\n  // [ 1, 2, 3 ]\n  //    ^-^\n  // -> Remove element 2 and apply 0,-3 offset to 1\n  //\n  // [table]\n  // a = 1\n  // b = 2 # X\n  // c = 3\n  // -> Remove element 2 and apply -1,0 offset to 1\n  if (!hasItems(parent)) {\n    throw new Error(`Unsupported parent type \"${parent.type}\" for remove`);\n  }\n\n  let index = parent.items.indexOf(node);\n  if (index < 0) {\n    // Try again, looking at child items for nodes like InlineArrayItem\n    index = parent.items.findIndex(item => hasItem(item) && item.item === node);\n\n    if (index < 0) {\n      throw new Error('Could not find node in parent for removal');\n    }\n\n    node = parent.items[index];\n  }\n\n  const previous = parent.items[index - 1];\n  let next = parent.items[index + 1];\n\n  // Remove node\n  parent.items.splice(index, 1);\n  let removed_span = getSpan(node.loc);\n\n  // Remove an associated comment that appears on the same line\n  //\n  // [table]\n  // a = 1\n  // b = 2 # remove this too\n  // c = 3\n  //\n  // TODO InlineTable - this only applies to comments in Table/TableArray\n  if (next && isComment(next) && next.loc.start.line === node.loc.end.line) {\n    // Add comment to removed\n    removed_span = getSpan({ start: node.loc.start, end: next.loc.end });\n\n    // Shift to next item\n    // (use same index since node has already been removed)\n    next = parent.items[index + 1];\n\n    // Remove comment\n    parent.items.splice(index, 1);\n  }\n\n  // For inline tables and arrays, check whether the line should be kept\n  const is_inline = previous && isInlineItem(previous);\n  const previous_on_same_line = previous && previous.loc.end.line === node.loc.start.line;\n  const next_on_sameLine = next && next.loc.start.line === node.loc.end.line;\n  const keep_line = is_inline && (previous_on_same_line || next_on_sameLine);\n\n  const offset = {\n    lines: -(removed_span.lines - (keep_line ? 1 : 0)),\n    columns: -removed_span.columns\n  };\n\n  // Offset for comma and remove comma from previous (if-needed)\n  if (is_inline && previous_on_same_line) {\n    offset.columns -= 2;\n  }\n  if (is_inline && previous && !next) {\n    (previous as InlineArrayItem | InlineTableItem).comma = false;\n  }\n\n  // Apply offsets after preceding node or before children of parent node\n  const target = previous || parent;\n  const target_offsets = previous ? getExit(root) : getEnter(root);\n  const node_offsets = getExit(root);\n  const previous_offset = target_offsets.get(target);\n  if (previous_offset) {\n    offset.lines += previous_offset.lines;\n    offset.columns += previous_offset.columns;\n  }\n  const removed_offset = node_offsets.get(node);\n  if (removed_offset) {\n    offset.lines += removed_offset.lines;\n    offset.columns += removed_offset.columns;\n  }\n\n  target_offsets.set(target, offset);\n}\n\nexport function applyBracketSpacing(\n  root: Root,\n  node: InlineArray | InlineTable,\n  bracket_spacing: boolean = true\n) {\n  // Can only add bracket spacing currently\n  if (!bracket_spacing) return;\n  if (!node.items.length) return;\n\n  // Apply enter to node so that items are affected\n  addOffset({ lines: 0, columns: 1 }, getEnter(root), node);\n\n  // Apply exit to last node in items\n  const last_item = last(node.items as Node[])!;\n  addOffset({ lines: 0, columns: 1 }, getExit(root), last_item);\n}\n\nexport function applyTrailingComma(\n  root: Root,\n  node: InlineArray | InlineTable,\n  trailing_commas: boolean = false\n) {\n  // Can only add trailing comma currently\n  if (!trailing_commas) return;\n  if (!node.items.length) return;\n\n  const last_item = last(node.items)!;\n  last_item.comma = true;\n\n  addOffset({ lines: 0, columns: 1 }, getExit(root), last_item);\n}\n\nexport function applyWrites(root: Node) {\n  const enter = getEnter(root);\n  const exit = getExit(root);\n\n  const offset: { lines: number; columns: { [index: number]: number } } = {\n    lines: 0,\n    columns: {}\n  };\n\n  function shiftStart(node: Node) {\n    node.loc.start.line += offset.lines;\n    node.loc.start.column += offset.columns[node.loc.start.line] || 0;\n\n    const entering = enter.get(node);\n    if (entering) {\n      offset.lines += entering.lines;\n      offset.columns[node.loc.start.line] =\n        (offset.columns[node.loc.start.line] || 0) + entering.columns;\n    }\n  }\n  function shiftEnd(node: Node) {\n    node.loc.end.line += offset.lines;\n    node.loc.end.column += offset.columns[node.loc.end.line] || 0;\n\n    const exiting = exit.get(node);\n    if (exiting) {\n      offset.lines += exiting.lines;\n      offset.columns[node.loc.end.line] =\n        (offset.columns[node.loc.end.line] || 0) + exiting.columns;\n    }\n  }\n  const shiftLocation = {\n    enter: shiftStart,\n    exit: shiftEnd\n  };\n\n  traverse(root, {\n    [NodeType.Document]: shiftLocation,\n    [NodeType.Table]: shiftLocation,\n    [NodeType.TableArray]: shiftLocation,\n    [NodeType.InlineTable]: shiftLocation,\n    [NodeType.InlineArray]: shiftLocation,\n\n    [NodeType.InlineItem]: shiftLocation,\n    [NodeType.TableKey]: shiftLocation,\n    [NodeType.TableArrayKey]: shiftLocation,\n\n    [NodeType.KeyValue]: {\n      enter(node) {\n        const start_line = node.loc.start.line + offset.lines;\n        const key_offset = exit.get(node.key);\n        node.equals += (offset.columns[start_line] || 0) + (key_offset ? key_offset.columns : 0);\n\n        shiftStart(node);\n      },\n      exit: shiftEnd\n    },\n\n    [NodeType.Key]: shiftLocation,\n    [NodeType.String]: shiftLocation,\n    [NodeType.Integer]: shiftLocation,\n    [NodeType.Float]: shiftLocation,\n    [NodeType.Boolean]: shiftLocation,\n    [NodeType.DateTime]: shiftLocation,\n    [NodeType.Comment]: shiftLocation\n  });\n\n  enter_offsets.delete(root);\n  exit_offsets.delete(root);\n}\n\nexport function shiftNode(\n  node: Node,\n  span: Span,\n  options: { first_line_only?: boolean } = {}\n): Node {\n  const { first_line_only = false } = options;\n  const start_line = node.loc.start.line;\n  const { lines, columns } = span;\n  const move = (node: Node) => {\n    if (!first_line_only || node.loc.start.line === start_line) {\n      node.loc.start.column += columns;\n      node.loc.end.column += columns;\n    }\n    node.loc.start.line += lines;\n    node.loc.end.line += lines;\n  };\n\n  traverse(node, {\n    [NodeType.Table]: move,\n    [NodeType.TableKey]: move,\n    [NodeType.TableArray]: move,\n    [NodeType.TableArrayKey]: move,\n    [NodeType.KeyValue](node) {\n      move(node);\n      node.equals += columns;\n    },\n    [NodeType.Key]: move,\n    [NodeType.String]: move,\n    [NodeType.Integer]: move,\n    [NodeType.Float]: move,\n    [NodeType.Boolean]: move,\n    [NodeType.DateTime]: move,\n    [NodeType.InlineArray]: move,\n    [NodeType.InlineItem]: move,\n    [NodeType.InlineTable]: move,\n    [NodeType.Comment]: move\n  });\n\n  return node;\n}\n\nfunction perLine(array: InlineArray): boolean {\n  if (!array.items.length) return false;\n\n  const span = getSpan(array.loc);\n  return span.lines > array.items.length;\n}\n\nfunction addOffset(offset: Span, offsets: Offsets, node: Node, from?: Node) {\n  const previous_offset = offsets.get(from || node);\n  if (previous_offset) {\n    offset.lines += previous_offset.lines;\n    offset.columns += previous_offset.columns;\n  }\n\n  offsets.set(node, offset);\n}\n","import {\n  NodeType,\n  Document,\n  Table,\n  TableKey,\n  TableArray,\n  TableArrayKey,\n  Value,\n  KeyValue,\n  Key,\n  String,\n  Integer,\n  Float,\n  Boolean,\n  DateTime,\n  InlineArray,\n  InlineItem,\n  InlineTable,\n  Comment\n} from './ast';\nimport { zero, cloneLocation, clonePosition } from './location';\nimport { shiftNode } from './writer';\n\nexport function generateDocument(): Document {\n  return {\n    type: NodeType.Document,\n    loc: { start: zero(), end: zero() },\n    items: []\n  };\n}\n\nexport function generateTable(key: string[]): Table {\n  const table_key = generateTableKey(key);\n\n  return {\n    type: NodeType.Table,\n    loc: cloneLocation(table_key.loc),\n    key: table_key,\n    items: []\n  };\n}\n\nexport function generateTableKey(key: string[]): TableKey {\n  const raw = keyValueToRaw(key);\n\n  return {\n    type: NodeType.TableKey,\n    loc: {\n      start: zero(),\n      end: { line: 1, column: raw.length + 2 }\n    },\n    item: {\n      type: NodeType.Key,\n      loc: {\n        start: { line: 1, column: 1 },\n        end: { line: 1, column: raw.length + 1 }\n      },\n      value: key,\n      raw\n    }\n  };\n}\n\nexport function generateTableArray(key: string[]): TableArray {\n  const table_array_key = generateTableArrayKey(key);\n\n  return {\n    type: NodeType.TableArray,\n    loc: cloneLocation(table_array_key.loc),\n    key: table_array_key,\n    items: []\n  };\n}\n\nexport function generateTableArrayKey(key: string[]): TableArrayKey {\n  const raw = keyValueToRaw(key);\n\n  return {\n    type: NodeType.TableArrayKey,\n    loc: {\n      start: zero(),\n      end: { line: 1, column: raw.length + 4 }\n    },\n    item: {\n      type: NodeType.Key,\n      loc: {\n        start: { line: 1, column: 2 },\n        end: { line: 1, column: raw.length + 2 }\n      },\n      value: key,\n      raw\n    }\n  };\n}\n\nexport function generateKeyValue(key: string[], value: Value): KeyValue {\n  const key_node = generateKey(key);\n  const { column } = key_node.loc.end;\n\n  const equals = column + 1;\n\n  shiftNode(\n    value,\n    { lines: 0, columns: column + 3 - value.loc.start.column },\n    { first_line_only: true }\n  );\n\n  return {\n    type: NodeType.KeyValue,\n    loc: {\n      start: clonePosition(key_node.loc.start),\n      end: clonePosition(value.loc.end)\n    },\n    key: key_node,\n    equals,\n    value\n  };\n}\n\nconst IS_BARE_KEY = /[\\w,\\d,\\_,\\-]+/;\nfunction keyValueToRaw(value: string[]): string {\n  return value.map(part => (IS_BARE_KEY.test(part) ? part : JSON.stringify(part))).join('.');\n}\n\nexport function generateKey(value: string[]): Key {\n  const raw = keyValueToRaw(value);\n\n  return {\n    type: NodeType.Key,\n    loc: { start: zero(), end: { line: 1, column: raw.length } },\n    raw,\n    value\n  };\n}\n\nexport function generateString(value: string): String {\n  const raw = JSON.stringify(value);\n\n  return {\n    type: NodeType.String,\n    loc: { start: zero(), end: { line: 1, column: raw.length } },\n    raw,\n    value\n  };\n}\n\nexport function generateInteger(value: number): Integer {\n  const raw = value.toString();\n\n  return {\n    type: NodeType.Integer,\n    loc: { start: zero(), end: { line: 1, column: raw.length } },\n    raw,\n    value\n  };\n}\n\nexport function generateFloat(value: number): Float {\n  const raw = value.toString();\n\n  return {\n    type: NodeType.Float,\n    loc: { start: zero(), end: { line: 1, column: raw.length } },\n    raw,\n    value\n  };\n}\n\nexport function generateBoolean(value: boolean): Boolean {\n  return {\n    type: NodeType.Boolean,\n    loc: { start: zero(), end: { line: 1, column: value ? 4 : 5 } },\n    value\n  };\n}\n\nexport function generateDateTime(value: Date): DateTime {\n  const raw = value.toISOString();\n\n  return {\n    type: NodeType.DateTime,\n    loc: { start: zero(), end: { line: 1, column: raw.length } },\n    raw,\n    value\n  };\n}\n\nexport function generateInlineArray(): InlineArray {\n  return {\n    type: NodeType.InlineArray,\n    loc: { start: zero(), end: { line: 1, column: 2 } },\n    items: []\n  };\n}\n\nexport function generateInlineItem(item: KeyValue | Value): InlineItem {\n  return {\n    type: NodeType.InlineItem,\n    loc: cloneLocation(item.loc),\n    item,\n    comma: false\n  };\n}\n\nexport function generateInlineTable(): InlineTable {\n  return {\n    type: NodeType.InlineTable,\n    loc: { start: zero(), end: { line: 1, column: 2 } },\n    items: []\n  };\n}\n\nexport function generateComment(comment: string): Comment {\n  if (!comment.startsWith('#')) comment = `# ${comment}`;\n\n  return {\n    type: NodeType.Comment,\n    loc: { start: zero(), end: { line: 1, column: comment.length } },\n    raw: comment\n  };\n}\n","import {\n  KeyValue,\n  Table,\n  InlineTable,\n  TableArray,\n  InlineArray,\n  isInlineTable,\n  isInlineArray,\n  isKeyValue,\n  Document\n} from './ast';\nimport { generateTable, generateDocument, generateTableArray } from './generate';\nimport { insert, remove, applyWrites, shiftNode } from './writer';\n\nexport interface Format {\n  printWidth?: number;\n  tabWidth?: number;\n  useTabs?: boolean;\n  trailingComma?: boolean;\n  bracketSpacing?: boolean;\n}\n\nexport function formatTopLevel(document: Document): Document {\n  const move_to_top_level = document.items.filter(item => {\n    if (!isKeyValue(item)) return false;\n\n    const is_inline_table = isInlineTable(item.value);\n    const is_inline_array =\n      isInlineArray(item.value) &&\n      item.value.items.length &&\n      isInlineTable(item.value.items[0].item);\n\n    return is_inline_table || is_inline_array;\n  }) as KeyValue[];\n\n  move_to_top_level.forEach(node => {\n    remove(document, document, node);\n\n    if (isInlineTable(node.value)) {\n      insert(document, document, formatTable(node));\n    } else {\n      formatTableArray(node).forEach(table_array => {\n        insert(document, document, table_array);\n      });\n    }\n  });\n\n  applyWrites(document);\n  return document;\n}\n\nfunction formatTable(key_value: KeyValue): Table {\n  const table = generateTable(key_value.key.value);\n\n  for (const item of (key_value.value as InlineTable).items) {\n    insert(table, table, item.item);\n  }\n\n  applyWrites(table);\n  return table;\n}\n\nfunction formatTableArray(key_value: KeyValue): TableArray[] {\n  const root = generateDocument();\n\n  for (const inline_array_item of (key_value.value as InlineArray).items) {\n    const table_array = generateTableArray(key_value.key.value);\n    insert(root, root, table_array);\n\n    for (const inline_table_item of (inline_array_item.item as InlineTable).items) {\n      insert(root, table_array, inline_table_item.item);\n    }\n  }\n\n  applyWrites(root);\n  return root.items as TableArray[];\n}\n\nexport function formatPrintWidth(document: Document, format: Format): Document {\n  // TODO\n  return document;\n}\n\nexport function formatEmptyLines(document: Document): Document {\n  let shift = 0;\n  let previous = 0;\n  for (const item of document.items) {\n    if (previous === 0 && item.loc.start.line > 1) {\n      // Remove leading newlines\n      shift = 1 - item.loc.start.line;\n    } else if (item.loc.start.line + shift > previous + 2) {\n      shift += previous + 2 - (item.loc.start.line + shift);\n    }\n\n    shiftNode(item, {\n      lines: shift,\n      columns: 0\n    });\n    previous = item.loc.end.line;\n  }\n\n  return document;\n}\n","import { Value, KeyValue, Document, InlineArray, InlineTable } from './ast';\nimport {\n  generateDocument,\n  generateKeyValue,\n  generateInlineItem,\n  generateString,\n  generateInteger,\n  generateFloat,\n  generateBoolean,\n  generateDateTime,\n  generateInlineArray,\n  generateInlineTable\n} from './generate';\nimport { Format, formatTopLevel, formatPrintWidth, formatEmptyLines } from './format';\nimport { isObject, isString, isInteger, isFloat, isBoolean, isDate, pipe } from './utils';\nimport { insert, applyWrites, applyBracketSpacing, applyTrailingComma } from './writer';\n\nconst default_format = {\n  printWidth: 80,\n  trailingComma: false,\n  bracketSpacing: true\n};\n\nexport default function parseJS(value: any, format: Format = {}): Document {\n  format = Object.assign({}, default_format, format);\n  value = toJSON(value);\n\n  const document = generateDocument();\n  for (const item of walkObject(value, format)) {\n    insert(document, document, item);\n  }\n  applyWrites(document);\n\n  // Heuristics:\n  // 1. Top-level objects/arrays should be tables/table arrays\n  // 2. Convert objects/arrays to tables/table arrays based on print width\n  const formatted = pipe(\n    document,\n    formatTopLevel,\n    document => formatPrintWidth(document, format),\n    formatEmptyLines\n  );\n\n  return formatted;\n}\n\nfunction* walkObject(object: any, format: Format): IterableIterator<KeyValue> {\n  for (const key of Object.keys(object)) {\n    yield generateKeyValue([key], walkValue(object[key], format));\n  }\n}\n\nfunction walkValue(value: any, format: Format): Value {\n  if (value == null) {\n    throw new Error('\"null\" and \"undefined\" values are not supported');\n  }\n\n  if (isString(value)) {\n    return generateString(value);\n  } else if (isInteger(value)) {\n    return generateInteger(value);\n  } else if (isFloat(value)) {\n    return generateFloat(value);\n  } else if (isBoolean(value)) {\n    return generateBoolean(value);\n  } else if (isDate(value)) {\n    return generateDateTime(value);\n  } else if (Array.isArray(value)) {\n    return walkInlineArray(value, format);\n  } else {\n    return walkInlineTable(value, format);\n  }\n}\n\nfunction walkInlineArray(value: Array<any>, format: Format): InlineArray {\n  const inline_array = generateInlineArray();\n  for (const element of value) {\n    const item = walkValue(element, format);\n    const inline_array_item = generateInlineItem(item);\n\n    insert(inline_array, inline_array, inline_array_item);\n  }\n  applyBracketSpacing(inline_array, inline_array, format.bracketSpacing);\n  applyTrailingComma(inline_array, inline_array, format.trailingComma);\n  applyWrites(inline_array);\n\n  return inline_array;\n}\n\nfunction walkInlineTable(value: object, format: Format): InlineTable | Value {\n  value = toJSON(value);\n  if (!isObject(value)) return walkValue(value, format);\n\n  const inline_table = generateInlineTable();\n  const items = [...walkObject(value, format)];\n  for (const item of items) {\n    const inline_table_item = generateInlineItem(item);\n\n    insert(inline_table, inline_table, inline_table_item);\n  }\n  applyBracketSpacing(inline_table, inline_table, format.bracketSpacing);\n  applyTrailingComma(inline_table, inline_table, format.trailingComma);\n  applyWrites(inline_table);\n\n  return inline_table;\n}\n\nfunction toJSON(value: any): any {\n  return value && !isDate(value) && typeof value.toJSON === 'function' ? value.toJSON() : value;\n}\n","import { NodeType, AST } from './ast';\nimport traverse from './traverse';\nimport { Location } from './location';\nimport { SPACE } from './tokenizer';\n\nconst BY_NEW_LINE = /(\\r\\n|\\n)/g;\n\nexport default function toTOML(ast: AST, newline: string = '\\n'): string {\n  const lines: string[] = [];\n\n  traverse(ast, {\n    [NodeType.TableKey](node) {\n      const { start, end } = node.loc;\n\n      write(lines, { start, end: { line: start.line, column: start.column + 1 } }, '[');\n      write(lines, { start: { line: end.line, column: end.column - 1 }, end }, ']');\n    },\n    [NodeType.TableArrayKey](node) {\n      const { start, end } = node.loc;\n\n      write(lines, { start, end: { line: start.line, column: start.column + 2 } }, '[[');\n      write(lines, { start: { line: end.line, column: end.column - 2 }, end }, ']]');\n    },\n\n    [NodeType.KeyValue](node) {\n      const {\n        start: { line }\n      } = node.loc;\n      write(\n        lines,\n        { start: { line, column: node.equals }, end: { line, column: node.equals + 1 } },\n        '='\n      );\n    },\n    [NodeType.Key](node) {\n      write(lines, node.loc, node.raw);\n    },\n\n    [NodeType.String](node) {\n      write(lines, node.loc, node.raw);\n    },\n    [NodeType.Integer](node) {\n      write(lines, node.loc, node.raw);\n    },\n    [NodeType.Float](node) {\n      write(lines, node.loc, node.raw);\n    },\n    [NodeType.Boolean](node) {\n      write(lines, node.loc, node.value.toString());\n    },\n    [NodeType.DateTime](node) {\n      write(lines, node.loc, node.raw);\n    },\n\n    [NodeType.InlineArray](node) {\n      const { start, end } = node.loc;\n      write(lines, { start, end: { line: start.line, column: start.column + 1 } }, '[');\n      write(lines, { start: { line: end.line, column: end.column - 1 }, end }, ']');\n    },\n\n    [NodeType.InlineTable](node) {\n      const { start, end } = node.loc;\n      write(lines, { start, end: { line: start.line, column: start.column + 1 } }, '{');\n      write(lines, { start: { line: end.line, column: end.column - 1 }, end }, '}');\n    },\n    [NodeType.InlineItem](node) {\n      if (!node.comma) return;\n\n      const start = node.loc.end;\n      write(lines, { start, end: { line: start.line, column: start.column + 1 } }, ',');\n    },\n\n    [NodeType.Comment](node) {\n      write(lines, node.loc, node.raw);\n    }\n  });\n\n  return lines.join(newline) + newline;\n}\n\nfunction write(lines: string[], loc: Location, raw: string) {\n  const raw_lines = raw.split(BY_NEW_LINE);\n  const expected_lines = loc.end.line - loc.start.line + 1;\n\n  if (raw_lines.length !== expected_lines) {\n    throw new Error(\n      `Mismatch between location and raw string, expected ${expected_lines} lines for \"${raw}\"`\n    );\n  }\n\n  for (let i = loc.start.line; i <= loc.end.line; i++) {\n    const line = getLine(lines, i);\n    const is_start_line = i === loc.start.line;\n    const is_end_line = i === loc.end.line;\n\n    const before = is_start_line\n      ? line.substr(0, loc.start.column).padEnd(loc.start.column, SPACE)\n      : '';\n    const after = is_end_line ? line.substr(loc.end.column) : '';\n\n    lines[i - 1] = before + raw_lines[i - loc.start.line] + after;\n  }\n}\n\nfunction getLine(lines: string[], index: number): string {\n  if (!lines[index - 1]) {\n    for (let i = 0; i < index; i++) {\n      if (!lines[i]) lines[i] = '';\n    }\n  }\n\n  return lines[index - 1];\n}\n","import { Value, NodeType, Node, AST, isInlineTable } from './ast';\nimport traverse from './traverse';\nimport { last, blank, isDate, has } from './utils';\nimport ParseError from './parse-error';\n\nexport default function toJS(ast: AST, input: string = ''): any {\n  const result = blank();\n  const tables: Set<string> = new Set();\n  const table_arrays: Set<string> = new Set();\n  const defined: Set<string> = new Set();\n  let active: any = result;\n  let previous_active: any;\n  let skip = false;\n\n  traverse(ast, {\n    [NodeType.Table](node) {\n      const key = node.key.item.value;\n      try {\n        validateKey(result, key, node.type, { tables, table_arrays, defined });\n      } catch (err) {\n        throw new ParseError(input, node.key.loc.start, err.message);\n      }\n\n      const joined_key = joinKey(key);\n      tables.add(joined_key);\n      defined.add(joined_key);\n\n      active = ensureTable(result, key);\n    },\n\n    [NodeType.TableArray](node) {\n      const key = node.key.item.value;\n\n      try {\n        validateKey(result, key, node.type, { tables, table_arrays, defined });\n      } catch (err) {\n        throw new ParseError(input, node.key.loc.start, err.message);\n      }\n\n      const joined_key = joinKey(key);\n      table_arrays.add(joined_key);\n      defined.add(joined_key);\n\n      active = ensureTableArray(result, key);\n    },\n\n    [NodeType.KeyValue]: {\n      enter(node) {\n        if (skip) return;\n\n        const key = node.key.value;\n        try {\n          validateKey(active, key, node.type, { tables, table_arrays, defined });\n        } catch (err) {\n          throw new ParseError(input, node.key.loc.start, err.message);\n        }\n\n        const value = toValue(node.value);\n        const target = key.length > 1 ? ensureTable(active, key.slice(0, -1)) : active;\n\n        target[last(key)!] = value;\n        defined.add(joinKey(key));\n\n        if (isInlineTable(node.value)) {\n          previous_active = active;\n          active = value;\n        }\n      },\n      exit(node) {\n        if (isInlineTable(node.value)) {\n          active = previous_active;\n        }\n      }\n    },\n\n    [NodeType.InlineTable]: {\n      enter() {\n        // Handled by toValue\n        skip = true;\n      },\n      exit() {\n        skip = false;\n      }\n    }\n  });\n\n  return result;\n}\n\nexport function toValue(node: Value): any {\n  switch (node.type) {\n    case NodeType.InlineTable:\n      const result = blank();\n\n      node.items.forEach(({ item }) => {\n        const key = item.key.value;\n        const value = toValue(item.value);\n\n        const target = key.length > 1 ? ensureTable(result, key.slice(0, -1)) : result;\n        target[last(key)!] = value;\n      });\n\n      return result;\n\n    case NodeType.InlineArray:\n      return node.items.map(item => toValue(item.item as Value));\n\n    case NodeType.String:\n    case NodeType.Integer:\n    case NodeType.Float:\n    case NodeType.Boolean:\n    case NodeType.DateTime:\n      return node.value;\n\n    default:\n      throw new Error(`Unrecognized value type \"${(node as Node).type}\"`);\n  }\n}\n\nfunction validateKey(\n  object: any,\n  key: string[],\n  type: NodeType.Table | NodeType.TableArray | NodeType.KeyValue,\n  state: { tables: Set<string>; table_arrays: Set<string>; defined: Set<string> }\n) {\n  // 1. Cannot override primitive value\n  let parts: string[] = [];\n  let index = 0;\n  for (const part of key) {\n    parts.push(part);\n\n    if (!has(object, part)) return;\n    if (isPrimitive(object[part])) {\n      throw new Error(`Invalid key, a value has already been defined for ${parts.join('.')}`);\n    }\n\n    const joined_parts = joinKey(parts);\n    if (Array.isArray(object[part]) && !state.table_arrays.has(joined_parts)) {\n      throw new Error(`Invalid key, cannot add to a static array at ${joined_parts}`);\n    }\n\n    const next_is_last = index++ < key.length - 1;\n    object = Array.isArray(object[part]) && next_is_last ? last(object[part]) : object[part];\n  }\n\n  const joined_key = joinKey(key);\n\n  // 2. Cannot override table\n  if (object && type === NodeType.Table && state.defined.has(joined_key)) {\n    throw new Error(`Invalid key, a table has already been defined named ${joined_key}`);\n  }\n\n  // 3. Cannot add table array to static array or table\n  if (object && type === NodeType.TableArray && !state.table_arrays.has(joined_key)) {\n    throw new Error(`Invalid key, cannot add an array of tables to a table at ${joined_key}`);\n  }\n}\n\nfunction ensureTable(object: any, key: string[]): any {\n  const target = ensure(object, key.slice(0, -1));\n  const last_key = last(key)!;\n  if (!target[last_key]) {\n    target[last_key] = blank();\n  }\n\n  return target[last_key];\n}\n\nfunction ensureTableArray(object: any, key: string[]): any {\n  const target = ensure(object, key.slice(0, -1));\n  const last_key = last(key)!;\n  if (!target[last_key]) {\n    target[last_key] = [];\n  }\n\n  const next = blank();\n  target[last(key)!].push(next);\n\n  return next;\n}\n\nfunction ensure(object: any, keys: string[]): any {\n  return keys.reduce((active, subkey) => {\n    if (!active[subkey]) {\n      active[subkey] = blank();\n    }\n    return Array.isArray(active[subkey]) ? last(active[subkey]) : active[subkey];\n  }, object);\n}\n\nfunction isPrimitive(value: any) {\n  return typeof value !== 'object' && !isDate(value);\n}\n\nfunction joinKey(key: string[]): string {\n  return key.join('.');\n}\n","import { isObject, datesEqual, stableStringify, merge } from './utils';\nimport { Path } from './find-by-path';\n\nexport enum ChangeType {\n  Add = 'Add',\n  Edit = 'Edit',\n  Remove = 'Remove',\n  Move = 'Move',\n  Rename = 'Rename'\n}\n\nexport interface Add {\n  type: ChangeType.Add;\n  path: Path;\n}\nexport function isAdd(change: Change): change is Add {\n  return change.type === ChangeType.Add;\n}\n\nexport interface Edit {\n  type: ChangeType.Edit;\n  path: Path;\n}\nexport function isEdit(change: Change): change is Edit {\n  return change.type === ChangeType.Edit;\n}\n\nexport interface Remove {\n  type: ChangeType.Remove;\n  path: Path;\n}\nexport function isRemove(change: Change): change is Remove {\n  return change.type === ChangeType.Remove;\n}\n\nexport interface Move {\n  type: ChangeType.Move;\n  path: Path;\n  from: number;\n  to: number;\n}\nexport function isMove(change: Change): change is Move {\n  return change.type === ChangeType.Move;\n}\n\nexport interface Rename {\n  type: ChangeType.Rename;\n  path: Path;\n  from: string;\n  to: string;\n}\nexport function isRename(change: Change): change is Rename {\n  return change.type === ChangeType.Rename;\n}\n\nexport type Change = Add | Edit | Remove | Move | Rename;\n\nexport default function diff(before: any, after: any, path: Path = []): Change[] {\n  if (before === after || datesEqual(before, after)) {\n    return [];\n  }\n\n  if (Array.isArray(before) && Array.isArray(after)) {\n    return compareArrays(before, after, path);\n  } else if (isObject(before) && isObject(after)) {\n    return compareObjects(before, after, path);\n  } else {\n    return [\n      {\n        type: ChangeType.Edit,\n        path\n      }\n    ];\n  }\n}\n\nfunction compareObjects(before: any, after: any, path: Path = []): Change[] {\n  let changes: Change[] = [];\n\n  // 1. Get keys and stable values\n  const before_keys = Object.keys(before);\n  const before_stable = before_keys.map(key => stableStringify(before[key]));\n  const after_keys = Object.keys(after);\n  const after_stable = after_keys.map(key => stableStringify(after[key]));\n\n  // Check for rename by seeing if object is in both before and after\n  // and that key is no longer used in after\n  const isRename = (stable: string, search: string[]) => {\n    const index = search.indexOf(stable);\n    if (index < 0) return false;\n\n    const before_key = before_keys[before_stable.indexOf(stable)];\n    return !after_keys.includes(before_key);\n  };\n\n  // 2. Check for changes, rename, and removed\n  before_keys.forEach((key, index) => {\n    const sub_path = path.concat(key);\n    if (after_keys.includes(key)) {\n      merge(changes, diff(before[key], after[key], sub_path));\n    } else if (isRename(before_stable[index], after_stable)) {\n      const to = after_keys[after_stable.indexOf(before_stable[index])];\n      changes.push({\n        type: ChangeType.Rename,\n        path,\n        from: key,\n        to\n      });\n    } else {\n      changes.push({\n        type: ChangeType.Remove,\n        path: sub_path\n      });\n    }\n  });\n\n  // 3. Check for additions\n  after_keys.forEach((key, index) => {\n    if (!before_keys.includes(key) && !isRename(after_stable[index], before_stable)) {\n      changes.push({\n        type: ChangeType.Add,\n        path: path.concat(key)\n      });\n    }\n  });\n\n  return changes;\n}\n\nfunction compareArrays(before: any[], after: any[], path: Path = []): Change[] {\n  let changes: Change[] = [];\n\n  // 1. Convert arrays to stable objects\n  const before_stable = before.map(stableStringify);\n  const after_stable = after.map(stableStringify);\n\n  // 2. Step through after array making changes to before array as-needed\n  after_stable.forEach((value, index) => {\n    const overflow = index >= before_stable.length;\n\n    // Check if items are the same\n    if (!overflow && before_stable[index] === value) {\n      return;\n    }\n\n    // Check if item has been moved -> shift into place\n    const from = before_stable.indexOf(value, index + 1);\n    if (!overflow && from > -1) {\n      changes.push({\n        type: ChangeType.Move,\n        path,\n        from,\n        to: index\n      });\n\n      const move = before_stable.splice(from, 1);\n      before_stable.splice(index, 0, ...move);\n\n      return;\n    }\n\n    // Check if item is removed -> assume it's been edited and replace\n    const removed = !after_stable.includes(before_stable[index]);\n    if (!overflow && removed) {\n      merge(changes, diff(before[index], after[index], path.concat(index)));\n      before_stable[index] = value;\n\n      return;\n    }\n\n    // Add as new item and shift existing\n    changes.push({\n      type: ChangeType.Add,\n      path: path.concat(index)\n    });\n    before_stable.splice(index, 0, value);\n  });\n\n  // 3. Remove any remaining overflow items\n  for (let i = after_stable.length; i < before_stable.length; i++) {\n    changes.push({\n      type: ChangeType.Remove,\n      path: path.concat(i)\n    });\n  }\n\n  return changes;\n}\n","import { Node, isKeyValue, isTable, isTableArray, hasItems, isInlineItem, hasItem } from './ast';\nimport { arraysEqual, stableStringify } from './utils';\n\nexport type Path = Array<string | number>;\n\nexport default function findByPath(node: Node, path: Path): Node {\n  if (!path.length) return node;\n\n  if (isKeyValue(node)) {\n    return findByPath(node.value, path);\n  }\n\n  const indexes: { [key: string]: number } = {};\n  let found;\n  if (hasItems(node)) {\n    node.items.some((item, index) => {\n      try {\n        let key: Path = [];\n        if (isKeyValue(item)) {\n          key = item.key.value;\n        } else if (isTable(item)) {\n          key = item.key.item.value;\n        } else if (isTableArray(item)) {\n          key = item.key.item.value;\n\n          const key_string = stableStringify(key);\n          if (!indexes[key_string]) {\n            indexes[key_string] = 0;\n          }\n          const array_index = indexes[key_string]++;\n\n          key = key.concat(array_index);\n        } else if (isInlineItem(item) && isKeyValue(item.item)) {\n          key = item.item.key.value;\n        } else if (isInlineItem(item)) {\n          key = [index];\n        }\n\n        if (key.length && arraysEqual(key, path.slice(0, key.length))) {\n          found = findByPath(item, path.slice(key.length));\n          return true;\n        } else {\n          return false;\n        }\n      } catch (err) {\n        return false;\n      }\n    });\n  }\n\n  if (!found) {\n    throw new Error(`Could not find node at path ${path.join('.')}`);\n  }\n\n  return found;\n}\n\nexport function tryFindByPath(node: Node, path: Path): Node | undefined {\n  try {\n    return findByPath(node, path);\n  } catch (err) {}\n}\n\nexport function findParent(node: Node, path: Path): Node {\n  let parent_path = path;\n  let parent;\n  while (parent_path.length && !parent) {\n    parent_path = parent_path.slice(0, -1);\n    parent = tryFindByPath(node, parent_path);\n  }\n\n  if (!parent) {\n    throw new Error(`Count not find parent node for path ${path.join('.')}`);\n  }\n\n  return parent;\n}\n","import parseTOML from './parse-toml';\nimport parseJS from './parse-js';\nimport toJS from './to-js';\nimport toTOML from './to-toml';\nimport { Format } from './format';\nimport {\n  isKeyValue,\n  WithItems,\n  KeyValue,\n  isTable,\n  Node,\n  Document,\n  isDocument,\n  Block,\n  NodeType,\n  isTableArray,\n  isInlineArray,\n  hasItem,\n  InlineItem\n} from './ast';\nimport diff, { Change, isAdd, isEdit, isRemove, isMove, isRename } from './diff';\nimport findByPath, { tryFindByPath, findParent } from './find-by-path';\nimport { last, isInteger } from './utils';\nimport { insert, replace, remove, applyWrites } from './writer';\n\nexport default function patch(existing: string, updated: any, format?: Format): string {\n  const existing_ast = parseTOML(existing);\n  const items = [...existing_ast];\n\n  const existing_js = toJS(items);\n  const existing_document: Document = {\n    type: NodeType.Document,\n    loc: { start: { line: 1, column: 0 }, end: { line: 1, column: 0 } },\n    items\n  };\n\n  const updated_document = parseJS(updated, format);\n  const changes = diff(existing_js, updated);\n\n  const patched_document = applyChanges(existing_document, updated_document, changes);\n\n  return toTOML(patched_document.items);\n}\n\nfunction applyChanges(original: Document, updated: Document, changes: Change[]): Document {\n  // Potential Changes:\n  //\n  // Add: Add key-value to object, add item to array\n  // Edit: Change in value\n  // Remove: Remove key-value from object, remove item from array\n  // Move: Move item in array\n  // Rename: Rename key in key-value\n  //\n  // Special consideration, inline comments need to move as-needed\n\n  changes.forEach(change => {\n    if (isAdd(change)) {\n      const child = findByPath(updated, change.path);\n      const parent_path = change.path.slice(0, -1);\n      let index = last(change.path)! as number;\n\n      let is_table_array = isTableArray(child);\n      if (isInteger(index) && !parent_path.some(isInteger)) {\n        const sibling = tryFindByPath(original, parent_path.concat(0));\n        if (sibling && isTableArray(sibling)) {\n          is_table_array = true;\n        }\n      }\n\n      let parent: Node;\n      if (isTable(child)) {\n        parent = original;\n      } else if (is_table_array) {\n        parent = original;\n\n        // The index needs to be updated to top-level items\n        // to properly account for other items, comments, and nesting\n        const document = original as Document;\n        const before = tryFindByPath(document, parent_path.concat(index - 1)) as Block | undefined;\n        const after = tryFindByPath(document, parent_path.concat(index)) as Block | undefined;\n        if (after) {\n          index = document.items.indexOf(after);\n        } else if (before) {\n          index = document.items.indexOf(before) + 1;\n        } else {\n          index = document.items.length;\n        }\n      } else {\n        parent = findParent(original, change.path);\n        if (isKeyValue(parent)) parent = parent.value;\n      }\n\n      if (isTableArray(parent) || isInlineArray(parent) || isDocument(parent)) {\n        insert(original, parent, child, index);\n      } else {\n        insert(original, parent, child);\n      }\n    } else if (isEdit(change)) {\n      let existing = findByPath(original, change.path);\n      let replacement = findByPath(updated, change.path);\n      let parent;\n\n      if (isKeyValue(existing) && isKeyValue(replacement)) {\n        // Edit for key-value means value changes\n        parent = existing;\n        existing = existing.value;\n        replacement = replacement.value;\n      } else {\n        parent = findParent(original, change.path);\n      }\n\n      replace(original, parent, existing, replacement);\n    } else if (isRemove(change)) {\n      let parent = findParent(original, change.path);\n      if (isKeyValue(parent)) parent = parent.value;\n\n      const node = findByPath(original, change.path);\n\n      remove(original, parent, node);\n    } else if (isMove(change)) {\n      let parent = findByPath(original, change.path);\n      if (hasItem(parent)) parent = parent.item;\n      if (isKeyValue(parent)) parent = parent.value;\n\n      const node = (parent as WithItems).items[change.from];\n\n      remove(original, parent, node);\n      insert(original, parent, node, change.to);\n    } else if (isRename(change)) {\n      let parent = findByPath(original, change.path.concat(change.from)) as\n        | KeyValue\n        | InlineItem<KeyValue>;\n      let replacement = findByPath(updated, change.path.concat(change.to)) as\n        | KeyValue\n        | InlineItem<KeyValue>;\n\n      if (hasItem(parent)) parent = parent.item;\n      if (hasItem(replacement)) replacement = replacement.item;\n\n      replace(original, parent, parent.key, replacement.key);\n    }\n  });\n\n  applyWrites(original);\n  return original;\n}\n","import parseTOML from './parse-toml';\nimport parseJS from './parse-js';\nimport toTOML from './to-toml';\nimport toJS from './to-js';\nimport { Format } from './format';\n\nexport function parse(value: string): any {\n  return toJS(parseTOML(value), value);\n}\n\nexport function stringify(value: any, format?: Format): string {\n  const document = parseJS(value, format);\n  return toTOML(document.items);\n}\n\nexport { default as patch } from './patch';\n"],"names":["NodeType","TokenType","isDocument","node","type","Document","isTable","Table","isTableKey","TableKey","isTableArray","TableArray","isTableArrayKey","TableArrayKey","isKeyValue","KeyValue","isInlineArray","InlineArray","isInlineItem","InlineItem","isInlineTable","InlineTable","isComment","Comment","hasItems","hasItem","isBlock","iterator","value","Symbol","Cursor","[object Object]","this","index","undefined","done","peeked","result","next","getSpan","location","lines","end","line","start","columns","column","createLocate","input","findLines","findPosition","Array","isArray","findIndex","line_index","getLine","position","length","substr","BY_NEW_LINE","indexes","match","exec","push","clonePosition","cloneLocation","zero","ParseError","Error","message","error_message","pointer","whitespace","super","count","character","repeat","IS_WHITESPACE","IS_NEW_LINE","DOUBLE_QUOTE","SINGLE_QUOTE","SPACE","ESCAPE","IS_VALID_LEADING_CHARACTER","tokenize","cursor","locate","test","specialCharacter","Bracket","Curly","Equal","Comma","Dot","comment","multiline_char","checkThree","multiline","string","raw","loc","peek","quotes","Literal","double_quoted","single_quoted","isFinished","next_item","current","check","last","values","blank","Object","create","isString","isInteger","isFloat","isBoolean","isDate","prototype","toString","call","isObject","isIterable","has","object","key","hasOwnProperty","arraysEqual","a","b","i","datesEqual","toISOString","pipe","fns","reduce","fn","stableStringify","keys","sort","map","JSON","stringify","join","merge","target","original_length","added_length","TRIPLE_DOUBLE_QUOTE","TRIPLE_SINGLE_QUOTE","LF","CRLF","IS_CRLF","IS_LF","IS_LEADING_NEW_LINE","IS_LINE_ENDING_BACKSLASH","parseString","startsWith","trim","trimLeadingWhitespace","lineEndingBackslash","escapeNewLines","unescape","escaped","json_escaped","replace","code_point","parseInt","as_string","String","fromCodePoint","parse","TRUE","FALSE","HAS_E","IS_DIVIDER","IS_INF","IS_NAN","IS_HEX","IS_OCTAL","IS_BINARY","IS_FULL_DATE","IS_FULL_TIME","parseTOML","tokens","walkBlock","table","keyValue","walkValue","boolean","datetime","float","integer","inlineTable","inline_array","comments","inlineArray","is_table","item","Key","dot","before","after","items","equals","Boolean","Date","local_date","split","DateTime","Infinity","Number","Float","Integer","radix","previous","comma","inline_item","additional_comments","traverse","ast","visitor","traverseArray","array","parent","traverseNode","visit","enter","exit","enter_offsets","WeakMap","getEnter","root","set","get","exit_offsets","getExit","existing","replacement","indexOf","splice","shiftNode","existing_span","replacement_span","addOffset","insert","child","shift","offset","insertInline","insertOnNewLine","previous_offset","delete","use_first_line","is_block","leading_lines","child_span","is_last","leading_comma","trailing_comma","last_comma","use_new_line","perLine","skip_comma","skip_bracket","remove","removed_span","is_inline","previous_on_same_line","next_on_sameLine","keep_line","target_offsets","node_offsets","removed_offset","applyBracketSpacing","bracket_spacing","last_item","applyTrailingComma","trailing_commas","applyWrites","shiftStart","entering","shiftEnd","exiting","shiftLocation","start_line","key_offset","span","options","first_line_only","move","offsets","from","generateDocument","generateTable","table_key","generateTableKey","keyValueToRaw","generateTableArray","table_array_key","generateTableArrayKey","generateKeyValue","key_node","generateKey","IS_BARE_KEY","part","generateString","generateInteger","generateFloat","generateBoolean","generateDateTime","generateInlineArray","generateInlineItem","generateInlineTable","formatTopLevel","document","filter","is_inline_table","is_inline_array","forEach","formatTable","formatTableArray","table_array","key_value","inline_array_item","inline_table_item","formatPrintWidth","format","formatEmptyLines","default_format","printWidth","trailingComma","bracketSpacing","parseJS","assign","toJSON","walkObject","walkInlineArray","walkInlineTable","element","inline_table","toTOML","newline","write","raw_lines","expected_lines","is_start_line","is_end_line","padEnd","toJS","tables","Set","table_arrays","defined","previous_active","active","skip","validateKey","err","joined_key","joinKey","add","ensureTable","ensureTableArray","toValue","slice","state","parts","isPrimitive","joined_parts","next_is_last","ensure","last_key","subkey","ChangeType","isAdd","change","Add","isEdit","Edit","isRemove","Remove","isMove","Move","isRename","Rename","diff","path","compareArrays","compareObjects","changes","before_keys","before_stable","after_keys","after_stable","stable","search","before_key","includes","sub_path","concat","to","overflow","removed","findByPath","found","some","key_string","array_index","tryFindByPath","findParent","parent_path","patch","updated","existing_js","applyChanges","original","is_table_array","sibling"],"mappings":"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"}